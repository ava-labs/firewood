// Copyright (C) 2023, Ava Labs, Inc. All rights reserved.
// See the file LICENSE.md for licensing terms.

#![allow(dead_code)]
// Allow clippy warnings that are generated by the derivative crate's code generation.
// The derivative crate generates Debug implementations that trigger these warnings,
// but we can't control the generated code and these patterns are necessary for the crate to work.
#![allow(clippy::borrowed_box)] // Derivative generates &Box<T> patterns
#![allow(clippy::needless_lifetimes)] // Derivative generates explicit lifetimes that clippy thinks are unnecessary

use std::cmp::Ordering;
use std::fmt;
use storage::{Child, FileIoError, Node, Path, SharedNode, TrieReader, logger::trace};

use crate::db::BatchOp;
use crate::merkle::{Key, Merkle, Value};
use crate::stream::{
    IterationNode, NodeStreamState, as_enumerated_children_iter, key_from_nibble_iter,
};
use derivative::Derivative;

// State structs for different types of diff iteration nodes

/// Two nodes that need to be compared against each other.
/// This state occurs when we have matching children in both trees that need to be processed,
/// or when we're starting the comparison at the root level with nodes from both trees.
///
/// The "unvisited" part means that we haven't actually consumed the value
/// in a branch, or we haven't consumed the value of the leaf.
#[derive(Debug)]
struct UnvisitedNodePairState {
    node_left: SharedNode,
    node_right: SharedNode,
}

/// A node that exists only in the left tree (tree1) and needs to be processed for deletion.
/// This state occurs when comparing children and the left tree has a child at a position
/// where the right tree doesn't, or when the entire left subtree needs to be deleted.
#[derive(Debug)]
struct UnvisitedNodeLeftState {
    node: SharedNode,
    excluded_node: Option<(SharedNode, Path)>,
}

/// A node that exists only in the right tree (tree2) and needs to be processed for addition.
/// This state occurs when comparing children and the right tree has a child at a position
/// where the left tree doesn't, or when the entire right subtree needs to be added.
#[derive(Debug)]
struct UnvisitedNodeRightState {
    node: SharedNode,
    excluded_node: Option<(SharedNode, Path)>,
}

/// Two branch nodes whose children are being compared.
/// This state occurs when we have branch nodes from both trees and we need to iterate
/// through their children to find differences between the subtrees.
#[derive(Derivative)]
#[derivative(Debug)]
struct VisitedNodePairState {
    #[derivative(Debug(format_with = "fmt_as_iterator"))]
    children_iter_left: Box<dyn Iterator<Item = (u8, Child)> + Send>,
    #[derivative(Debug(format_with = "fmt_as_iterator"))]
    children_iter_right: Box<dyn Iterator<Item = (u8, Child)> + Send>,
}

/// A branch node from the left tree only, whose children all need to be processed as deletions.
/// This state occurs when there are no remaining children on the right side to compare against,
/// or when we have a branch node that exists only in the left tree.
///
/// If included_node is Some, one child that matches the included node should be compared
/// instead of deleted (used in Branch vs Leaf scenarios).
///
/// This is always a leaf node (never a branch) because it comes from Branch vs Leaf scenarios
/// where we're traversing a branch's children but need to include any child that represents
/// the same logical key as a leaf from the other tree.
#[derive(Derivative)]
#[derivative(Debug)]
struct VisitedNodeLeftState {
    #[derivative(Debug(format_with = "fmt_as_iterator"))]
    children_iter: Box<dyn Iterator<Item = (u8, Child)> + Send>,
    /// Optional included node - if present, children matching this should be compared instead of deleted.
    excluded_leaf: Option<(SharedNode, Path)>,
}

/// A branch node from the right tree only, whose children all need to be processed as additions.
/// This state occurs when there are no remaining children on the left side to compare against,
/// or when we have a branch node that exists only in the right tree.
#[derive(Derivative)]
#[derivative(Debug)]
struct VisitedNodeRightState {
    #[derivative(Debug(format_with = "fmt_as_iterator"))]
    children_iter: Box<dyn Iterator<Item = (u8, Child)> + Send>,
    /// Optional excluded node - if present, children matching this should be compared instead of added.
    excluded_leaf: Option<(SharedNode, Path)>,
}

// Helper function for derivative to format iterators
fn fmt_as_iterator<T>(_: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    f.write_str("\"<iterator>\"")
}

trait StateVisitor {
    fn visit<L: TrieReader, R: TrieReader>(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError>;
}

trait UnvisitedStateVisitor {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError>;
}

#[derive(Debug, Default)]
struct IterStack {
    stack: Vec<DiffIterationNode>,
}

impl IterStack {
    fn push(&mut self, node: DiffIterationNode) {
        trace!(
            "pushing new state {{ key: {:x?}, state: {:?} }}",
            node.key, node.state
        );
        if node.key.starts_with(&[0, 7, 7]) {
            trace!("found key {:x?}", node.key);
        }
        self.stack.push(node);
    }
}

impl std::ops::Deref for IterStack {
    type Target = Vec<DiffIterationNode>;

    fn deref(&self) -> &Self::Target {
        &self.stack
    }
}

impl std::ops::DerefMut for IterStack {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.stack
    }
}

impl UnvisitedStateVisitor for UnvisitedNodePairState {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError> {
        // This is the initial state for comparing two nodes. They are unvisited.
        // For branches, this means we haven't looked at the k/v pair in the branch
        // nor have we looked at any of the children.
        // For leaves, this means we haven't looked at the k/v pair in the leaf.

        // There are 4 possibilities:
        // 1. Both nodes are branches:
        // .  Process the branch k/v, then transition to VisitedPairState
        // 2. Both nodes are leaves:
        // .  Process the leaf k/v, then pop the stack
        // 3. Left node is a branch, right node is a leaf:
        // .  Compare the branch k/v with the leaf k/v. If they have the same
        // .  partial path, then everything except for this leaf is deleted,
        // .  and we transition to VisitedLeftState with the leaf excluded
        // 4. Left node is a leaf, right node is a branch:
        // .  Compare the leaf k/v with the branch k/v. If they have the same
        // .  partial path, then everything except for this leaf is added,
        // .  and we transition to VisitedRightState with the leaf excluded

        trace!(
            "visiting Unvisited node pair at {key:x?} (depth: {})",
            iter_stack.len()
        );

        match (&*self.node_left, &*self.node_right) {
            (Node::Branch(branch_left), Node::Branch(branch_right)) => {
                // Compare values first
                let value_diff = match (&branch_left.value, &branch_right.value) {
                    (Some(v_left), Some(v_right)) if v_left == v_right => None,
                    (Some(_), None) => Some(BatchOp::Delete {
                        key: key_from_nibble_iter(key.iter().copied()),
                    }),
                    (_, Some(v_right)) => Some(BatchOp::Put {
                        key: key_from_nibble_iter(key.iter().copied()),
                        value: v_right.to_vec(),
                    }),
                    (None, None) => None,
                };

                // Set up to compare children
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                        children_iter_left: Box::new(as_enumerated_children_iter(branch_left)),
                        children_iter_right: Box::new(as_enumerated_children_iter(branch_right)),
                    }),
                });

                Ok(value_diff)
            }
            (Node::Branch(branch), Node::Leaf(leaf)) => {
                // Branch is from left tree, leaf is from right tree
                // This means all (except possibly one) of the k/v pairs
                // on this branch have been deleted.

                // This leaf, however, is special. If it matches some key in the branch,
                // and contains the same value as the leaf, then no diff is needed.
                // If it is found, but doesn't have the same value, we generate a put
                // operation with the leaf's value. We save this leaf into the
                // VisitedNodeLeftState structure and follow the logic there.

                // rare case: the branch itself represents the same logical key as the leaf
                if branch.partial_path == leaf.partial_path {
                    trace!("branch vs leaf, same path {key:x?}");
                    // continue with all remaining children as deletions, with no
                    // special handling for this leaf, since it's value is in the branch
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                            children_iter: Box::new(as_enumerated_children_iter(branch)),
                            excluded_leaf: None,
                        }),
                    });
                    return if let Some(branch_val) = &branch.value {
                        // If the branch value also matches, we can just forget about this leaf
                        if branch_val != &leaf.value {
                            // the branch has a different value, so we need to generate a put
                            // operation for the leaf
                            Ok(Some(BatchOp::Put {
                                key: key_from_nibble_iter(key.iter().copied()),
                                value: leaf.value.to_vec(),
                            }))
                        } else {
                            Ok(None)
                        }
                    } else {
                        // the branch has no value, so the leaf is new, and we need to process the
                        // remaining items on the branch as deletes
                        Ok(Some(BatchOp::Put {
                            key: key_from_nibble_iter(key.iter().copied()),
                            value: leaf.value.to_vec(),
                        }))
                    };
                }
                // TODO: maybe the leaf is down in the branch somewhere. If we never find it,
                // then it's brand new data

                // Set up to traverse branch children, but exclude any that are equivalent to the leaf
                // key already has the branch's partial path added, we need to remove that before chaining the child
                let leaf_key = Path::from_nibbles_iterator(
                    key.iter()
                        .take(key.len().saturating_sub(branch.partial_path.len()))
                        .copied()
                        .chain(leaf.partial_path.iter().copied()),
                );
                // let leaf_key = key.clone();
                trace!("key is {key:x?}");
                trace!("branch is {branch:?}");
                trace!("leaf is {leaf:?}");
                trace!("excluding leaf {leaf_key:x?} (for inserts)");
                trace!("switching to VisitedNodeLeftState");

                let din = DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: Box::new(as_enumerated_children_iter(branch)),
                        excluded_leaf: Some((self.node_right.clone(), leaf_key)),
                    }),
                };
                trace!("pushing {din:?}");
                iter_stack.push(din);

                // if the branch had a value, it's been deleted
                if let Some(_branch_val) = &branch.value {
                    Ok(Some(BatchOp::Delete {
                        key: key_from_nibble_iter(key.iter().copied()),
                    }))
                } else {
                    Ok(None)
                }
            }
            (Node::Leaf(leaf), Node::Branch(branch)) => {
                // Leaf vs Branch - save the leaf and traverse branch children with exclusion
                // Leaf is from left tree, branch is from right tree

                // Compare the leaf's value with the branch's own value
                // Only generate operations for actual value differences, not structural changes
                let value_diff = match &branch.value {
                    Some(branch_val) if branch_val == &leaf.value => None, // Same value, no operation needed
                    Some(different_val) => Some(BatchOp::Put {
                        // Branch has different value, update it
                        key: key_from_nibble_iter(key.iter().copied()),
                        value: different_val.to_vec(),
                    }),
                    None => {
                        // Branch has no value - this might be a structural optimization
                        // The leaf might be represented by one of the branch's children
                        // Don't generate a delete operation unless we're sure the leaf doesn't exist
                        None
                    }
                };

                // Set up to traverse branch children, but exclude any that are equivalent to the leaf
                // "key" already includes the full path to the leaf
                let leaf_key = key.clone();
                trace!("key is {key:x?}");
                trace!("branch is {branch:?}");
                trace!("leaf is {leaf:?}");
                trace!("excluding leaf {leaf_key:x?} (for deletes)");

                // remove the leaf's partial path, and add the branch's partial path
                let branch_key = Path::from_nibbles_iterator(
                    key.iter()
                        .take(key.len().saturating_sub(leaf.partial_path.len()))
                        .copied()
                        .chain(branch.partial_path.iter().copied()),
                );
                iter_stack.push(DiffIterationNode {
                    key: branch_key,
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: Box::new(as_enumerated_children_iter(branch)),
                        excluded_leaf: Some((self.node_left.clone(), leaf_key)),
                    }),
                });

                Ok(value_diff)
            }
            (Node::Leaf(leaf1), Node::Leaf(leaf2)) => {
                // Two leaves - compare values
                if leaf1.value != leaf2.value {
                    // The key already includes the complete path including partial paths
                    Ok(Some(BatchOp::Put {
                        key: key_from_nibble_iter(key.iter().copied()),
                        value: leaf2.value.to_vec(),
                    }))
                } else {
                    Ok(None)
                }
            }
        }
    }
}

impl UnvisitedStateVisitor for UnvisitedNodeLeftState {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError> {
        let final_key = key_from_nibble_iter(key.iter().copied());

        // Node exists only in tree1 - mark for deletion
        match &*self.node {
            Node::Branch(branch) => {
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: Box::new(as_enumerated_children_iter(branch)),
                        excluded_leaf: self.excluded_node,
                    }),
                });

                if branch.value.is_some() {
                    // The key already includes the complete path including partial paths
                    Ok(Some(BatchOp::Delete { key: final_key }))
                } else {
                    Ok(None)
                }
            }
            Node::Leaf(_leaf) => {
                // The key already includes the complete path including partial paths
                Ok(Some(BatchOp::Delete { key: final_key }))
            }
        }
    }
}

impl UnvisitedStateVisitor for UnvisitedNodeRightState {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError> {
        let current_key = Path::from_nibbles_iterator(key.iter().copied());

        // Node exists only in tree2 - mark for addition
        match &*self.node {
            Node::Branch(branch) => {
                iter_stack.push(DiffIterationNode {
                    key: current_key.clone(),
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: Box::new(as_enumerated_children_iter(branch)),
                        excluded_leaf: self.excluded_node,
                    }),
                });

                if let Some(value) = &branch.value {
                    // The key already includes the complete path including partial paths
                    Ok(Some(BatchOp::Put {
                        key: key_from_nibble_iter(current_key.iter().copied()),
                        value: value.to_vec(),
                    }))
                } else {
                    Ok(None)
                }
            }
            Node::Leaf(leaf) => {
                // The key already includes the complete path including partial paths
                Ok(Some(BatchOp::Put {
                    key: key_from_nibble_iter(current_key.iter().copied()),
                    value: leaf.value.to_vec(),
                }))
            }
        }
    }
}

impl StateVisitor for VisitedNodeLeftState {
    fn visit<L: TrieReader, R: TrieReader>(
        mut self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError> {
        if let Some((pos, child)) = self.children_iter.next() {
            let node = match child {
                Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                Child::Node(node) => node.clone().into(),
            };

            let child_key = Path::from_nibbles_iterator(
                key.iter()
                    .copied()
                    .chain(std::iter::once(pos))
                    .chain(node.partial_path().iter().copied()),
            );

            if let Some((excluded_node, excluded_path)) = self.excluded_leaf.take() {
                trace!("child_key is {child_key:x?}");
                trace!("LS checking....{child_key:x?} is excluded...");
                if excluded_path == child_key {
                    trace!("yes");
                    // Found the excluded child

                    // resume after the excluded child
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                            children_iter: self.children_iter,
                            excluded_leaf: None, // Already taken
                        }),
                    });

                    // Compare this child instead of deleting (using moved excluded_node)
                    iter_stack.push(DiffIterationNode {
                        key: child_key,
                        state: DiffIterationNodeState::UnvisitedPair(UnvisitedNodePairState {
                            node_left: node,
                            node_right: excluded_node, // Moved, no clone needed
                        }),
                    });
                } else {
                    // Not the excluded child - put it back and continue looking
                    trace!("no");
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                            children_iter: self.children_iter,
                            excluded_leaf: Some((excluded_node.clone(), excluded_path.clone())), // Put it back
                        }),
                    });

                    // Delete this child
                    iter_stack.push(DiffIterationNode {
                        key: child_key,
                        state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                            node,
                            excluded_node: Some((excluded_node, excluded_path)),
                        }),
                    });
                }
            } else {
                // No exclusion - delete all children
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: self.children_iter,
                        excluded_leaf: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key,
                    state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                        node,
                        excluded_node: None,
                    }),
                });
            }
        }
        Ok(())
    }
}

impl StateVisitor for VisitedNodePairState {
    fn visit<L: TrieReader, R: TrieReader>(
        mut self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError> {
        // Compare children from both trees
        let child_left_opt = self.children_iter_left.next();
        let child_right_opt = self.children_iter_right.next();

        match (child_left_opt, child_right_opt) {
            (Some((pos_left, child_left)), Some((pos_right, child_right))) => {
                match pos_left.cmp(&pos_right) {
                    Ordering::Equal => {
                        // Same position - check if subtrees are identical
                        if DiffMerkleNodeStream::<L, R>::child_identical(&child_left, &child_right)
                        {
                            // Identical subtrees, skip them and continue with remaining children
                            iter_stack.push(DiffIterationNode {
                                key: key.clone(),
                                state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                    children_iter_left: self.children_iter_left,
                                    children_iter_right: self.children_iter_right,
                                }),
                            });
                            return Ok(());
                        }

                        // Different subtrees, need to compare them
                        let node_left = match child_left {
                            Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                        };

                        let node_right = match child_right {
                            Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                        };

                        let child_key: Path = {
                            let nibbles: Vec<u8> = key
                                .iter()
                                .copied()
                                .chain(node_left.partial_path().iter().copied())
                                .collect();
                            Path::from(nibbles.as_slice())
                        };

                        // Continue with remaining children
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                children_iter_left: self.children_iter_left,
                                children_iter_right: self.children_iter_right,
                            }),
                        });

                        iter_stack.push(DiffIterationNode {
                            key: child_key,
                            state: DiffIterationNodeState::UnvisitedPair(UnvisitedNodePairState {
                                node_left,
                                node_right,
                            }),
                        });
                    }
                    Ordering::Less => {
                        // pos_left < pos_right: child exists in tree_left but not tree_right
                        let node_left = match child_left {
                            Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                        };

                        let child_key: Path = {
                            let nibbles: Vec<u8> = key
                                .iter()
                                .copied()
                                .chain(std::iter::once(pos_left))
                                .chain(node_left.partial_path().iter().copied())
                                .collect();
                            Path::from(nibbles.as_slice())
                        };

                        // Put back child_right for next iteration
                        let new_iter_right = std::iter::once((pos_right, child_right))
                            .chain(self.children_iter_right);
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                children_iter_left: self.children_iter_left,
                                children_iter_right: Box::new(new_iter_right),
                            }),
                        });

                        iter_stack.push(DiffIterationNode {
                            key: child_key,
                            state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                                node: node_left,
                                excluded_node: None,
                            }),
                        });
                    }
                    Ordering::Greater => {
                        // pos_left > pos_right: child exists in tree_right but not tree_left
                        let node_right = match child_right {
                            Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                        };

                        let child_key: Path = {
                            let nibbles: Vec<u8> = key
                                .iter()
                                .copied()
                                .chain(std::iter::once(pos_right))
                                .chain(node_right.partial_path().iter().copied())
                                .collect();
                            Path::from(nibbles.as_slice())
                        };

                        // Put back child_left for next iteration
                        let new_iter_left =
                            std::iter::once((pos_left, child_left)).chain(self.children_iter_left);
                        iter_stack.push(DiffIterationNode {
                            key: key.get(..key.len() - 1).unwrap_or_default().into(),
                            state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                children_iter_left: Box::new(new_iter_left),
                                children_iter_right: self.children_iter_right,
                            }),
                        });

                        iter_stack.push(DiffIterationNode {
                            key: child_key,
                            state: DiffIterationNodeState::UnvisitedRight(
                                UnvisitedNodeRightState {
                                    node: node_right,
                                    excluded_node: None,
                                },
                            ),
                        });
                    }
                }
            }
            (Some((pos_left, child_left)), None) => {
                // Only tree_left has remaining children
                let node_left = match child_left {
                    Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                    Child::Node(node) => node.clone().into(),
                };

                let child_key: Path = {
                    let nibbles: Vec<u8> = key
                        .iter()
                        .copied()
                        .chain(std::iter::once(pos_left))
                        .chain(node_left.partial_path().iter().copied())
                        .collect();
                    Path::from(nibbles.as_slice())
                };

                // Continue with remaining children from tree_left
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: self.children_iter_left,
                        excluded_leaf: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key,
                    state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                        node: node_left,
                        excluded_node: None,
                    }),
                });
            }
            (None, Some((pos_right, child_right))) => {
                // Only tree_right has remaining children
                let node_right = match child_right {
                    Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                    Child::Node(node) => node.clone().into(),
                };

                let child_partial_path = node_right.partial_path().iter().copied();
                let child_key: Path = {
                    let nibbles: Vec<u8> = key
                        .iter()
                        .copied()
                        .chain(std::iter::once(pos_right))
                        .chain(child_partial_path)
                        .collect();
                    Path::from(nibbles.as_slice())
                };

                // Continue with remaining children from tree_right
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: self.children_iter_right,
                        excluded_leaf: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key,
                    state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                        node: node_right,
                        excluded_node: None,
                    }),
                });
            }
            (None, None) => {
                // No more children in either tree, continue
            }
        }
        Ok(())
    }
}

impl StateVisitor for VisitedNodeRightState {
    fn visit<L: TrieReader, R: TrieReader>(
        mut self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError> {
        if let Some((pos, child)) = self.children_iter.next() {
            let node = match child {
                Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                Child::Node(node) => node.clone().into(),
            };

            let child_partial_path = node.partial_path().iter().copied();
            let child_key = Path::from_nibbles_iterator(
                key.iter()
                    .copied()
                    .chain(std::iter::once(pos))
                    .chain(child_partial_path),
            );
            let branch_key =
                Path::from_nibbles_iterator(key.iter().copied().chain(std::iter::once(pos)));

            // Check if this child should be compared instead of added
            if let Some((excluded_node, excluded_path)) = self.excluded_leaf.take() {
                trace!("RS checking....{child_key:x?} is excluded...");
                if excluded_path == child_key {
                    // Found the excluded child - compare instead of adding
                    trace!("yes");
                    iter_stack.push(DiffIterationNode {
                        key: branch_key,
                        state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                            children_iter: self.children_iter,
                            excluded_leaf: None,
                        }),
                    });
                    if excluded_node.value() != node.value() {
                        // all this work, and the value was different anyway, so we still need to add it
                        iter_stack.push(DiffIterationNode {
                            key: child_key,
                            state: DiffIterationNodeState::UnvisitedRight(
                                UnvisitedNodeRightState {
                                    node,
                                    excluded_node: None,
                                },
                            ),
                        });
                    }
                } else {
                    // Not the excluded child - add it
                    trace!("no");
                    iter_stack.push(DiffIterationNode {
                        key: branch_key,
                        state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                            children_iter: self.children_iter,
                            excluded_leaf: Some((excluded_node, excluded_path)),
                        }),
                    });
                    iter_stack.push(DiffIterationNode {
                        key: child_key,
                        state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                            node,
                            excluded_node: None,
                        }),
                    });
                }
            } else {
                // No inclusion - add all children
                iter_stack.push(DiffIterationNode {
                    key: branch_key,
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: self.children_iter,
                        excluded_leaf: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key,
                    state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                        node,
                        excluded_node: None,
                    }),
                });
            }
        }
        Ok(())
    }
}

/// Enum containing all possible states for a diff iteration node
#[derive(Debug)]
enum DiffIterationNodeState {
    /// Two unvisited nodes that should be compared
    UnvisitedPair(UnvisitedNodePairState),
    /// A node that exists only in tree1 (needs to be deleted)
    UnvisitedLeft(UnvisitedNodeLeftState),
    /// A node that exists only in tree2 (needs to be added)
    UnvisitedRight(UnvisitedNodeRightState),
    /// A pair of visited branch nodes - track which children to compare next
    VisitedPair(VisitedNodePairState),
    /// A visited branch node from tree1 only (may have exclusions)
    VisitedLeft(VisitedNodeLeftState),
    /// A visited branch node from tree2 only (may have exclusions)
    VisitedRight(VisitedNodeRightState),
}

/// Iteration node that tracks state for both trees simultaneously
#[derive(Debug)]
struct DiffIterationNode {
    key: Path,
    state: DiffIterationNodeState,
}

impl DiffIterationNode {
    /// Convert an `IterationNode` to a `DiffIterationNode` for left tree operations (deletions).
    fn from_left(node: IterationNode) -> Self {
        match node {
            IterationNode::Unvisited { key, node } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                        node,
                        excluded_node: None,
                    }),
                }
            }
            IterationNode::Visited { key, children_iter } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter,
                        excluded_leaf: None,
                    }),
                }
            }
        }
    }

    /// Convert an `IterationNode` to a `DiffIterationNode` for right tree operations (additions).
    fn from_right(node: IterationNode) -> Self {
        match node {
            IterationNode::Unvisited { key, node } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                        node,
                        excluded_node: None,
                    }),
                }
            }
            IterationNode::Visited { key, children_iter } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter,
                        excluded_leaf: None,
                    }),
                }
            }
        }
    }
}

/// State for the diff iterator that tracks lazy initialization
#[derive(Debug)]
enum DiffNodeStreamState {
    /// The iterator state is lazily initialized when next_internal is called
    /// for the first time. The iteration start key is stored here.
    StartFromKey(Key),
    /// The iterator is actively iterating over nodes
    Iterating { iter_stack: IterStack },
}

impl From<Key> for DiffNodeStreamState {
    fn from(key: Key) -> Self {
        Self::StartFromKey(key)
    }
}

/// Optimized node iterator that compares two merkle trees and skips matching subtrees
#[derive(Debug)]
struct DiffMerkleNodeStream<'a, T: TrieReader, U: TrieReader> {
    tree_left: &'a T,
    tree_right: &'a U,
    state: DiffNodeStreamState,
}

impl<'a, T: TrieReader, U: TrieReader> DiffMerkleNodeStream<'a, T, U> {
    fn new(tree_left: &'a T, tree_right: &'a U, start_key: Key) -> Self {
        Self {
            tree_left,
            tree_right,
            state: DiffNodeStreamState::from(start_key),
        }
    }

    /// Check if two children have the same hash or refer to the same node.
    ///
    /// This is used to determine if two subtrees are identical.
    ///
    /// For mutable trees, we can compare node addresses to detect identical subtrees
    /// This works because identical subtrees will share the same underlying Node reference
    /// For immutable trees, we can't know if they are the same, assume not
    fn child_identical(child_left: &Child, child_right: &Child) -> bool {
        match (child_left, child_right) {
            (Child::AddressWithHash(_, hash_left), Child::AddressWithHash(_, hash_right)) => {
                hash_left == hash_right
            }
            // At least one of the children is unhashed, so we can't know if they are the same, assume not
            _ => false,
        }
    }

    /// Returns the initial state for a diff iterator over the given trees which starts at `key`.
    fn get_diff_iterator_initial_state(
        tree_left: &T,
        tree_right: &U,
        key: &[u8],
    ) -> Result<DiffNodeStreamState, storage::FileIoError> {
        let root_left_opt = tree_left.root_node();
        let root_right_opt = tree_right.root_node();

        match (root_left_opt, root_right_opt) {
            (None, None) => {
                // Both trees are empty
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack::default(),
                })
            }
            (Some(_root_left), None) => {
                // Only tree_left has content - use single tree traversal for deletions
                let initial_state = NodeStreamState::get_iterator_initial_state(tree_left, key)?;
                let iter_stack = match initial_state {
                    NodeStreamState::StartFromKey(_) => vec![], // Should not happen
                    NodeStreamState::Iterating { iter_stack } => {
                        // Convert IterationNode to DiffIterationNode for left tree operations
                        iter_stack
                            .into_iter()
                            .map(DiffIterationNode::from_left)
                            .collect()
                    }
                };
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack { stack: iter_stack },
                })
            }
            (None, Some(_root_right)) => {
                // Only tree_right has content - use single tree traversal for additions
                let initial_state = NodeStreamState::get_iterator_initial_state(tree_right, key)?;
                let iter_stack = match initial_state {
                    NodeStreamState::StartFromKey(_) => vec![], // Should not happen
                    NodeStreamState::Iterating { iter_stack } => {
                        // Convert IterationNode to DiffIterationNode for right tree operations
                        iter_stack
                            .into_iter()
                            .map(DiffIterationNode::from_right)
                            .collect()
                    }
                };
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack { stack: iter_stack },
                })
            }
            (Some(root_left), Some(root_right)) => {
                // Both trees have content - need to compare them
                // Start with an empty path and let the node comparison logic handle partial paths
                // This ensures we don't double-add partial paths from different roots
                let root_key: Path = Path::from_nibbles_iterator(std::iter::empty());
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack {
                        stack: vec![DiffIterationNode {
                            key: root_key,
                            state: DiffIterationNodeState::UnvisitedPair(UnvisitedNodePairState {
                                node_left: root_left,
                                node_right: root_right,
                            }),
                        }],
                    },
                })
            }
        }
    }

    fn next_internal(&mut self) -> Option<Result<BatchOp<Key, Value>, storage::FileIoError>> {
        // Handle lazy initialization
        let iter_stack = match &mut self.state {
            DiffNodeStreamState::StartFromKey(key) => {
                match Self::get_diff_iterator_initial_state(self.tree_left, self.tree_right, key) {
                    Ok(new_state) => {
                        self.state = new_state;
                        return self.next_internal();
                    }
                    Err(e) => return Some(Err(e)),
                }
            }
            DiffNodeStreamState::Iterating { iter_stack } => iter_stack,
        };

        // We remove the most recent DiffIterationNode, but in some cases we will push it back onto the stack.
        while let Some(iter_node) = iter_stack.pop() {
            match iter_node.state {
                DiffIterationNodeState::UnvisitedPair(state) => {
                    match state.visit(&iter_node.key, iter_stack) {
                        Ok(Some(result)) => return Some(Ok(result)),
                        Ok(None) => continue,
                        Err(e) => return Some(Err(e)),
                    }
                }
                DiffIterationNodeState::UnvisitedLeft(state) => {
                    match state.visit(&iter_node.key, iter_stack) {
                        Ok(Some(result)) => return Some(Ok(result)),
                        Ok(None) => continue,
                        Err(e) => return Some(Err(e)),
                    }
                }
                DiffIterationNodeState::UnvisitedRight(state) => {
                    match state.visit(&iter_node.key, iter_stack) {
                        Ok(Some(result)) => return Some(Ok(result)),
                        Ok(None) => continue,
                        Err(e) => return Some(Err(e)),
                    }
                }
                DiffIterationNodeState::VisitedPair(state) => {
                    if let Err(e) = state.visit::<T, U>(
                        &iter_node.key,
                        iter_stack,
                        (self.tree_left, self.tree_right),
                    ) {
                        return Some(Err(e));
                    }
                }
                DiffIterationNodeState::VisitedLeft(state) => {
                    if let Err(e) = state.visit::<T, U>(
                        &iter_node.key,
                        iter_stack,
                        (self.tree_left, self.tree_right),
                    ) {
                        return Some(Err(e));
                    }
                }
                DiffIterationNodeState::VisitedRight(state) => {
                    if let Err(e) = state.visit::<T, U>(
                        &iter_node.key,
                        iter_stack,
                        (self.tree_left, self.tree_right),
                    ) {
                        return Some(Err(e));
                    }
                }
            }
        }
        None
    }
}

/// Optimized diff stream that uses DiffMerkleNodeStream for hash-based optimizations
#[derive(Derivative)]
#[derivative(Debug)]
struct DiffMerkleKeyValueStreams<'a, T: TrieReader, U: TrieReader> {
    #[derivative(Debug(format_with = "fmt_as_node_stream"))]
    node_stream: DiffMerkleNodeStream<'a, T, U>,
}

// Helper function for derivative to format node stream
fn fmt_as_node_stream<T>(_: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    f.write_str("\"<DiffMerkleNodeStream>\"")
}

impl<'a, T: TrieReader, U: TrieReader> DiffMerkleKeyValueStreams<'a, T, U> {
    fn new(tree_left: &'a T, tree_right: &'a U, start_key: Key) -> Self {
        Self {
            node_stream: DiffMerkleNodeStream::new(tree_left, tree_right, start_key),
        }
    }
}

impl<T: TrieReader, U: TrieReader> Iterator for DiffMerkleKeyValueStreams<'_, T, U> {
    type Item = Result<BatchOp<Key, Value>, storage::FileIoError>;

    fn next(&mut self) -> Option<Self::Item> {
        self.node_stream.next_internal()
    }
}

fn diff_merkle_iterator<'a, T1: TrieReader, T2: TrieReader>(
    m1: &'a Merkle<T1>,
    m2: &'a Merkle<T2>,
    start_key: Key,
) -> DiffMerkleKeyValueStreams<'a, T1, T2> {
    DiffMerkleKeyValueStreams::new(m1.nodestore(), m2.nodestore(), start_key)
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use super::*;
    use env_logger::WriteStyle;
    use std::sync::Arc;
    use storage::{ImmutableProposal, MemStore, MutableProposal, NodeStore};
    use test_case::test_case;

    fn create_test_merkle() -> Merkle<NodeStore<MutableProposal, MemStore>> {
        let memstore = MemStore::new(vec![]);
        let nodestore = NodeStore::new_empty_proposal(Arc::new(memstore));
        Merkle::from(nodestore)
    }

    fn populate_merkle(
        mut merkle: Merkle<NodeStore<MutableProposal, MemStore>>,
        items: &[(&[u8], &[u8])],
    ) -> Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> {
        for (key, value) in items {
            merkle
                .insert(key, value.to_vec().into_boxed_slice())
                .unwrap();
        }
        merkle.try_into().unwrap()
    }

    fn make_immutable(
        merkle: Merkle<NodeStore<MutableProposal, MemStore>>,
    ) -> Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> {
        merkle.try_into().unwrap()
    }

    #[test]
    fn test_diff_empty_mutable_trees() {
        // This is unlikely to happen in practice, but it helps cover the case where
        // hashes do not exist yet.
        let m1 = create_test_merkle();
        let m2 = create_test_merkle();

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));
        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_empty_trees() {
        let m1 = make_immutable(create_test_merkle());
        let m2 = make_immutable(create_test_merkle());

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));
        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_identical_trees() {
        let items = [
            (b"key1".as_slice(), b"value1".as_slice()),
            (b"key2".as_slice(), b"value2".as_slice()),
            (b"key3".as_slice(), b"value3".as_slice()),
        ];

        let m1 = populate_merkle(create_test_merkle(), &items);
        let m2 = populate_merkle(create_test_merkle(), &items);

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));
        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_additions_only() {
        let items = [
            (b"key1".as_slice(), b"value1".as_slice()),
            (b"key2".as_slice(), b"value2".as_slice()),
        ];

        let m1 = make_immutable(create_test_merkle());
        let m2 = populate_merkle(create_test_merkle(), &items);

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op1, BatchOp::Put { key, value } if key == Box::from(b"key1".as_slice()) && value == b"value1")
        );

        let op2 = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op2, BatchOp::Put { key, value } if key == Box::from(b"key2".as_slice()) && value == b"value2")
        );

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_deletions_only() {
        let items = [
            (b"key1".as_slice(), b"value1".as_slice()),
            (b"key2".as_slice(), b"value2".as_slice()),
        ];

        let m1 = populate_merkle(create_test_merkle(), &items);
        let m2 = make_immutable(create_test_merkle());

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op1, BatchOp::Delete { key } if key == Box::from(b"key1".as_slice())));

        let op2 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op2, BatchOp::Delete { key } if key == Box::from(b"key2".as_slice())));

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_modifications() {
        let m1 = populate_merkle(create_test_merkle(), &[(b"key1", b"old_value")]);
        let m2 = populate_merkle(create_test_merkle(), &[(b"key1", b"new_value")]);

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op, BatchOp::Put { key, value } if key == Box::from(b"key1".as_slice()) && value == b"new_value")
        );

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_mixed_operations() {
        // m1 has: key1=value1, key2=old_value, key3=value3
        // m2 has: key2=new_value, key4=value4
        // Expected: Delete key1, Put key2=new_value, Delete key3, Put key4=value4

        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"key1", b"value1"),
                (b"key2", b"old_value"),
                (b"key3", b"value3"),
            ],
        );

        let m2 = populate_merkle(
            create_test_merkle(),
            &[(b"key2", b"new_value"), (b"key4", b"value4")],
        );

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op1, BatchOp::Delete { key } if key == Box::from(b"key1".as_slice())));

        let op2 = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op2, BatchOp::Put { key, value } if key == Box::from(b"key2".as_slice()) && value == b"new_value")
        );

        let op3 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op3, BatchOp::Delete { key } if key == Box::from(b"key3".as_slice())));

        let op4 = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op4, BatchOp::Put { key, value } if key == Box::from(b"key4".as_slice()) && value == b"value4")
        );

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_with_start_key() {
        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"aaa", b"value1"),
                (b"bbb", b"value2"),
                (b"ccc", b"value3"),
            ],
        );

        let m2 = populate_merkle(
            create_test_merkle(),
            &[
                (b"aaa", b"value1"),   // Same
                (b"bbb", b"modified"), // Modified
                (b"ddd", b"value4"),   // Added
            ],
        );

        // Start from key "bbb" - should skip "aaa"
        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::from(b"bbb".as_slice()));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op1, BatchOp::Put { ref key, ref value } if **key == *b"bbb" && **value == *b"modified"),
            "Expected first operation to be Put bbb=modified, got: {op1:?}",
        );

        let op2 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op2, BatchOp::Delete { key } if key == Box::from(b"ccc".as_slice())));

        let op3 = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op3, BatchOp::Put { key, value } if key == Box::from(b"ddd".as_slice()) && value == b"value4")
        );

        assert!(diff_iter.next().is_none());
    }

    #[test]
    #[allow(clippy::indexing_slicing)]
    fn test_diff_interleaved_keys() {
        // m1: a, c, e
        // m2: b, c, d, f
        // Expected: Delete a, Put b, Put d, Delete e, Put f

        let m1 = populate_merkle(
            create_test_merkle(),
            &[(b"a", b"value_a"), (b"c", b"value_c"), (b"e", b"value_e")],
        );

        let m2 = populate_merkle(
            create_test_merkle(),
            &[
                (b"b", b"value_b"),
                (b"c", b"value_c"),
                (b"d", b"value_d"),
                (b"f", b"value_f"),
            ],
        );

        let diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let ops: Vec<_> = diff_iter.collect::<Result<Vec<_>, _>>().unwrap();

        assert_eq!(ops.len(), 5);
        assert!(matches!(ops[0], BatchOp::Delete { ref key } if **key == *b"a"));
        assert!(
            matches!(ops[1], BatchOp::Put { ref key, ref value } if **key == *b"b" && **value == *b"value_b")
        );
        assert!(
            matches!(ops[2], BatchOp::Put { ref key, ref value } if **key == *b"d" && **value == *b"value_d")
        );
        assert!(matches!(ops[3], BatchOp::Delete { ref key } if **key == *b"e"));
        assert!(
            matches!(ops[4], BatchOp::Put { ref key, ref value } if **key == *b"f" && **value == *b"value_f")
        );
        // Note: "c" should be skipped as it's identical in both trees
    }

    // example of running this test with a specific seed and maximum tracing in diff code:
    // FIREWOOD_TEST_SEED=14805530293320947613 RUST_LOG=firewood::diff=trace \
    //  cargo test --features logger diff::tests::diff_random_with_deletions
    #[test_case(false, false, 500)]
    #[test_case(false, true, 500)]
    #[test_case(true, false, 500)]
    #[test_case(true, true, 500)]
    #[allow(clippy::indexing_slicing)]
    fn diff_random_with_deletions(trie1_mutable: bool, trie2_mutable: bool, num_items: usize) {
        use rand::rngs::StdRng;
        use rand::{Rng, SeedableRng, rng};

        let _ = env_logger::builder()
            .write_style(WriteStyle::Never)
            .format_timestamp(None)
            .is_test(true)
            .try_init();

        // Read FIREWOOD_TEST_SEED from environment or use random seed
        let seed = std::env::var("FIREWOOD_TEST_SEED")
            .ok()
            .map_or_else(
                || None,
                |s| Some(str::parse(&s).expect("couldn't parse FIREWOOD_TEST_SEED; must be a u64")),
            )
            .unwrap_or(14805530293320947613);
        //.unwrap_or_else(|| rng().random());

        eprintln!("Seed {seed}: to rerun with this data, export FIREWOOD_TEST_SEED={seed}");
        let mut rng = StdRng::seed_from_u64(seed);

        // Generate random key-value pairs, ensuring uniqueness
        let mut items: Vec<(Vec<u8>, Vec<u8>)> = Vec::new();
        let mut seen_keys = std::collections::HashSet::new();

        while items.len() < num_items {
            let key_len = rng.random_range(1..=32);
            let value_len = rng.random_range(1..=64);

            let key: Vec<u8> = (0..key_len).map(|_| rng.random()).collect();

            // Only add if key is unique
            if seen_keys.insert(key.clone()) {
                let value: Vec<u8> = (0..value_len).map(|_| rng.random()).collect();
                items.push((key, value));
            }
        }

        // Create two identical merkles
        let mut m1 = create_test_merkle();
        let mut m2 = create_test_merkle();

        for (key, value) in &items {
            m1.insert(key, value.clone().into_boxed_slice()).unwrap();
            m2.insert(key, value.clone().into_boxed_slice()).unwrap();
        }

        // Pick two different random indices to delete
        let delete_idx1 = rng.random_range(0..items.len());
        let mut delete_idx2 = rng.random_range(0..items.len());
        while delete_idx2 == delete_idx1 {
            delete_idx2 = rng.random_range(0..items.len());
        }

        let deleted_key1 = &items[delete_idx1].0;
        let deleted_key2 = &items[delete_idx2].0;

        // Get the actual values from the trees before deletion (handles duplicate keys correctly)
        let _actual_value1 = m1.get_value(deleted_key1).unwrap().unwrap();
        let _actual_value2 = m2.get_value(deleted_key2).unwrap().unwrap();

        // Delete different keys from each merkle
        m1.remove(deleted_key1).unwrap();
        println!("expected put for key {:x?}", deleted_key1);
        //m2.remove(deleted_key2).unwrap();
        //println!("expected delete for key {:x?}", deleted_key2);

        // Convert to the appropriate type based on test parameters
        let ops: Vec<BatchOp<Box<[u8]>, Vec<u8>>> = if trie1_mutable && trie2_mutable {
            // Both mutable
            diff_merkle_iterator(&m1, &m2, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        } else if trie1_mutable && !trie2_mutable {
            // m1 mutable, m2 immutable
            let m2_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m2.try_into().unwrap();
            diff_merkle_iterator(&m1, &m2_immut, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        } else if !trie1_mutable && trie2_mutable {
            // m1 immutable, m2 mutable
            let m1_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m1.try_into().unwrap();
            diff_merkle_iterator(&m1_immut, &m2, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        } else {
            // Both immutable
            let m1_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m1.try_into().unwrap();
            let m2_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m2.try_into().unwrap();
            println!("---m1\n{}", m1_immut.dump().unwrap());
            println!("---m2\n{}", m2_immut.dump().unwrap());
            diff_merkle_iterator(&m1_immut, &m2_immut, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        };

        // Should have exactly 2 operations: 1 delete + 1 put
        if ops.len() != 2 {
            println!(
                "DEBUG: Expected 2 operations but got {} for seed {}",
                ops.len(),
                seed
            );
            for (i, op) in ops.iter().enumerate() {
                match op {
                    BatchOp::Delete { key } => {
                        println!("  {}: Delete key: {:x?}", i, key.as_ref());
                    }
                    BatchOp::Put { key, value: _ } => {
                        println!("  {}: Put key: {:x?}", i, key.as_ref());
                    }
                    BatchOp::DeleteRange { .. } => {
                        println!("  {}: DeleteRange", i);
                    }
                }
            }
        }
        assert_eq!(ops.len(), 2);
    }

    #[test]
    fn test_hash_optimization_reduces_node_reads() {
        // This test focuses specifically on validating that hash optimization reduces node reads
        // by comparing baseline full-traversal reads vs optimized diff operation reads.
        // Diff correctness is validated by other tests.
        use metrics::{Key, Label, Recorder};
        use metrics_util::registry::{AtomicStorage, Registry};
        use std::sync::Arc;
        use std::sync::atomic::Ordering;

        /// Test metrics recorder that captures counter values for testing
        #[derive(Debug, Clone)]
        struct TestRecorder {
            registry: Arc<Registry<Key, AtomicStorage>>,
        }

        impl TestRecorder {
            fn new() -> Self {
                Self {
                    registry: Arc::new(Registry::atomic()),
                }
            }

            fn get_counter_value(
                &self,
                key_name: &'static str,
                labels: &[(&'static str, &'static str)],
            ) -> u64 {
                let key = if labels.is_empty() {
                    Key::from_name(key_name)
                } else {
                    let label_vec: Vec<Label> =
                        labels.iter().map(|(k, v)| Label::new(*k, *v)).collect();
                    Key::from_name(key_name).with_extra_labels(label_vec)
                };

                self.registry
                    .get_counter_handles()
                    .into_iter()
                    .find(|(k, _)| k == &key)
                    .map(|(_, counter)| counter.load(Ordering::Relaxed))
                    .unwrap_or(0)
            }
        }

        impl Recorder for TestRecorder {
            fn describe_counter(
                &self,
                _key: metrics::KeyName,
                _unit: Option<metrics::Unit>,
                _description: metrics::SharedString,
            ) {
            }
            fn describe_gauge(
                &self,
                _key: metrics::KeyName,
                _unit: Option<metrics::Unit>,
                _description: metrics::SharedString,
            ) {
            }
            fn describe_histogram(
                &self,
                _key: metrics::KeyName,
                _unit: Option<metrics::Unit>,
                _description: metrics::SharedString,
            ) {
            }

            fn register_counter(
                &self,
                key: &Key,
                _metadata: &metrics::Metadata<'_>,
            ) -> metrics::Counter {
                self.registry
                    .get_or_create_counter(key, |c| c.clone().into())
            }

            fn register_gauge(
                &self,
                key: &Key,
                _metadata: &metrics::Metadata<'_>,
            ) -> metrics::Gauge {
                self.registry.get_or_create_gauge(key, |c| c.clone().into())
            }

            fn register_histogram(
                &self,
                key: &Key,
                _metadata: &metrics::Metadata<'_>,
            ) -> metrics::Histogram {
                self.registry
                    .get_or_create_histogram(key, |c| c.clone().into())
            }
        }

        // Set up test recorder - if it fails, skip the entire test
        let recorder = TestRecorder::new();
        if metrics::set_global_recorder(recorder.clone()).is_err() {
            println!("  Could not set test recorder (already set) - skipping test");
            return;
        }

        // Create test data with substantial shared content and unique content
        let tree1_items = [
            // Large shared content that will form identical subtrees
            (
                b"shared/branch_a/deep/file1".as_slice(),
                b"shared_value1".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file2".as_slice(),
                b"shared_value2".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file3".as_slice(),
                b"shared_value3".as_slice(),
            ),
            (b"shared/branch_b/file1".as_slice(), b"shared_b1".as_slice()),
            (b"shared/branch_b/file2".as_slice(), b"shared_b2".as_slice()),
            (
                b"shared/branch_c/deep/nested/file".as_slice(),
                b"shared_nested".as_slice(),
            ),
            (b"shared/common".as_slice(), b"common_value".as_slice()),
            // Unique to tree1
            (b"tree1_unique/x".as_slice(), b"x_value".as_slice()),
            (b"tree1_unique/y".as_slice(), b"y_value".as_slice()),
            (b"tree1_unique/z".as_slice(), b"z_value".as_slice()),
        ];

        let tree2_items = [
            // Identical shared content
            (
                b"shared/branch_a/deep/file1".as_slice(),
                b"shared_value1".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file2".as_slice(),
                b"shared_value2".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file3".as_slice(),
                b"shared_value3".as_slice(),
            ),
            (b"shared/branch_b/file1".as_slice(), b"shared_b1".as_slice()),
            (b"shared/branch_b/file2".as_slice(), b"shared_b2".as_slice()),
            (
                b"shared/branch_c/deep/nested/file".as_slice(),
                b"shared_nested".as_slice(),
            ),
            (b"shared/common".as_slice(), b"common_value".as_slice()),
            // Unique to tree2
            (b"tree2_unique/p".as_slice(), b"p_value".as_slice()),
            (b"tree2_unique/q".as_slice(), b"q_value".as_slice()),
            (b"tree2_unique/r".as_slice(), b"r_value".as_slice()),
        ];

        // Create immutable trees (required for hash-based optimization)
        let m1 = populate_merkle(create_test_merkle(), &tree1_items);
        let m2 = populate_merkle(create_test_merkle(), &tree2_items);

        // BASELINE: Measure total reads from complete tree traversals
        let baseline_reads_before =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);

        // Traverse tree1 completely
        let tree1_iter = m1.key_value_iter();
        let tree1_count = tree1_iter.count();

        // Traverse tree2 completely
        let tree2_iter = m2.key_value_iter();
        let tree2_count = tree2_iter.count();

        let baseline_reads_after =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);
        let baseline_reads = baseline_reads_after - baseline_reads_before;

        println!(
            "Baseline - Tree1 items: {}, Tree2 items: {}",
            tree1_count, tree2_count
        );
        println!(
            "Baseline total reads (both trees fully traversed): {}",
            baseline_reads
        );

        // DIFF TEST: Measure reads from hash-optimized diff operation
        let diff_reads_before =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);

        let diff_stream =
            DiffMerkleKeyValueStreams::new(m1.nodestore(), m2.nodestore(), Box::new([]));
        let diff_results_count = diff_stream.count();

        let diff_reads_after =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);
        let diff_reads = diff_reads_after - diff_reads_before;

        println!("Diff operation reads: {}", diff_reads);
        println!("Diff results count: {}", diff_results_count);

        // Both should have some reads since we're using immutable proposals
        assert!(
            baseline_reads > 0,
            "Expected baseline reads from tree traversals"
        );
        assert!(diff_reads > 0, "Expected reads from diff operation");

        // Verify hash optimization is working - should read FEWER nodes than full traversal
        assert!(
            diff_reads < baseline_reads,
            "Hash optimization failed: diff reads ({}) should be less than baseline ({}) for trees with shared content",
            diff_reads,
            baseline_reads
        );

        println!(
            " Node read optimization verified: {} vs {} reads",
            diff_reads, baseline_reads
        );

        // Verify we found some diff operations (exact count and content validated by other tests)
        assert!(
            diff_results_count > 0,
            "Expected to find diff operations for trees with different content"
        );

        println!("   - Baseline reads: {}", baseline_reads);
        println!(
            "   - Diff reads: {} ({:.1}% of baseline)",
            diff_reads,
            (diff_reads as f64 / baseline_reads as f64) * 100.0
        );
        println!(
            "   - Node read reduction: {} ({:.1}%)",
            baseline_reads - diff_reads,
            ((baseline_reads - diff_reads) as f64 / baseline_reads as f64) * 100.0
        );
        println!("   - Diff operations found: {}", diff_results_count);
    }

    #[test]
    fn test_diff_processes_all_branch_children() {
        // This test verifies the bug fix: ensure that after finding different children
        // at the same position in a branch, the algorithm continues to process remaining children
        let m1 = create_test_merkle();
        let m1 = populate_merkle(
            m1,
            &[
                (b"branch_a/file", b"shared_value"),    // This will be identical
                (b"branch_b/file", b"value1"),          // This will be changed
                (b"branch_c/file", b"left_only_value"), // This will be deleted
            ],
        );

        let m2 = create_test_merkle();
        let m2 = populate_merkle(
            m2,
            &[
                (b"branch_a/file", b"shared_value"),     // Identical to tree1
                (b"branch_b/file", b"value1_modified"),  // Different value
                (b"branch_d/file", b"right_only_value"), // This will be added
            ],
        );

        let diff_stream =
            DiffMerkleKeyValueStreams::new(m1.nodestore(), m2.nodestore(), Key::default());

        let results: Vec<_> = diff_stream.collect::<Result<Vec<_>, _>>().unwrap();

        // Should find all differences:
        // 1. branch_b/file modified
        // 2. branch_c/file deleted
        // 3. branch_d/file added
        assert_eq!(results.len(), 3, "Should find all 3 differences");

        // Verify specific operations
        let mut changes = 0;
        let mut deletions = 0;
        let mut additions = 0;

        for result in &results {
            match result {
                BatchOp::Put { key, value: _ } => {
                    if key.as_ref() == b"branch_b/file" {
                        changes += 1;
                        assert_eq!(&**key, b"branch_b/file");
                    } else if key.as_ref() == b"branch_d/file" {
                        additions += 1;
                        assert_eq!(&**key, b"branch_d/file");
                    }
                }
                BatchOp::Delete { key } => {
                    deletions += 1;
                    assert_eq!(&**key, b"branch_c/file");
                }
                BatchOp::DeleteRange { .. } => {
                    panic!("DeleteRange not expected in this test");
                }
            }
        }

        assert_eq!(changes, 1, "Should have 1 change");
        assert_eq!(deletions, 1, "Should have 1 deletion");
        assert_eq!(additions, 1, "Should have 1 addition");
    }

    #[test]
    fn test_all_six_diff_states_coverage() {
        // This test ensures comprehensive coverage of all 6 diff iteration states
        // by creating specific scenarios that guarantee each state is exercised

        // Create trees with carefully designed structure to trigger all states:
        // 1. Deep branching structure to ensure branch nodes exist
        // 2. Mix of shared, modified, left-only, and right-only content
        // 3. Different tree shapes to force visited states

        let tree1_data = vec![
            // Shared deep structure (will trigger VisitedNodePairState)
            (b"shared/deep/branch/file1".as_slice(), b"value1".as_slice()),
            (b"shared/deep/branch/file2".as_slice(), b"value2".as_slice()),
            (b"shared/deep/branch/file3".as_slice(), b"value3".as_slice()),
            // Modified values (will trigger UnvisitedNodePairState)
            (b"modified/path/file".as_slice(), b"old_value".as_slice()),
            // Left-only deep structure (will trigger VisitedNodeLeftState)
            (
                b"left_only/deep/branch/file1".as_slice(),
                b"left_val1".as_slice(),
            ),
            (
                b"left_only/deep/branch/file2".as_slice(),
                b"left_val2".as_slice(),
            ),
            (
                b"left_only/deep/branch/file3".as_slice(),
                b"left_val3".as_slice(),
            ),
            // Simple left-only (will trigger UnvisitedNodeLeftState)
            (
                b"simple_left_only".as_slice(),
                b"simple_left_value".as_slice(),
            ),
            // Mixed branch with some shared children
            (
                b"mixed_branch/shared_child".as_slice(),
                b"shared".as_slice(),
            ),
            (
                b"mixed_branch/left_child".as_slice(),
                b"left_value".as_slice(),
            ),
        ];

        let tree2_data = vec![
            // Same shared deep structure
            (b"shared/deep/branch/file1".as_slice(), b"value1".as_slice()),
            (b"shared/deep/branch/file2".as_slice(), b"value2".as_slice()),
            (b"shared/deep/branch/file3".as_slice(), b"value3".as_slice()),
            // Modified values
            (b"modified/path/file".as_slice(), b"new_value".as_slice()),
            // Right-only deep structure (will trigger VisitedNodeRightState)
            (
                b"right_only/deep/branch/file1".as_slice(),
                b"right_val1".as_slice(),
            ),
            (
                b"right_only/deep/branch/file2".as_slice(),
                b"right_val2".as_slice(),
            ),
            (
                b"right_only/deep/branch/file3".as_slice(),
                b"right_val3".as_slice(),
            ),
            // Simple right-only (will trigger UnvisitedNodeRightState)
            (
                b"simple_right_only".as_slice(),
                b"simple_right_value".as_slice(),
            ),
            // Mixed branch with some shared children
            (
                b"mixed_branch/shared_child".as_slice(),
                b"shared".as_slice(),
            ),
            (
                b"mixed_branch/right_child".as_slice(),
                b"right_value".as_slice(),
            ),
        ];

        let m1 = populate_merkle(create_test_merkle(), &tree1_data);
        let m2 = populate_merkle(create_test_merkle(), &tree2_data);

        let diff_iter = diff_merkle_iterator(&m1, &m2, Key::default());
        let results: Vec<_> = diff_iter.collect::<Result<Vec<_>, _>>().unwrap();

        // Verify we found the expected differences
        let mut deletions = 0;
        let mut additions = 0;

        for result in &results {
            match result {
                BatchOp::Put { .. } => additions += 1,
                BatchOp::Delete { .. } => deletions += 1,
                BatchOp::DeleteRange { .. } => {
                    panic!("DeleteRange not expected in this test");
                }
            }
        }

        // Expected differences using BatchOp representation:
        // - Both modifications and additions are represented as Put operations
        // - Deletions are Delete operations
        // - We expect multiple operations for the different scenarios
        assert!(deletions >= 4, "Expected at least 4 deletions");
        assert!(
            additions >= 4,
            "Expected at least 4 additions (includes modifications)"
        );

        println!(" All 6 diff states coverage test passed:");
        println!("   - Deletions: {}", deletions);
        println!("   - Additions (includes modifications): {}", additions);
        println!("   - This test exercises scenarios that should trigger:");
        println!("     1. UnvisitedNodePairState (comparing modified nodes)");
        println!("     2. UnvisitedNodeLeftState (simple left-only nodes)");
        println!("     3. UnvisitedNodeRightState (simple right-only nodes)");
        println!("     4. VisitedNodePairState (shared branch with different children)");
        println!("     5. VisitedNodeLeftState (left-only branch structures)");
        println!("     6. VisitedNodeRightState (right-only branch structures)");
    }

    #[test]
    fn test_branch_vs_leaf_state_transitions() {
        // This test specifically covers the branch-vs-leaf scenarios in UnvisitedNodePairState
        // which can trigger different state transitions

        // Tree1: Has a branch structure at "path"
        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"path/file1".as_slice(), b"value1".as_slice()),
                (b"path/file2".as_slice(), b"value2".as_slice()),
            ],
        );

        // Tree2: Has a leaf at "path"
        let m2 = populate_merkle(
            create_test_merkle(),
            &[(b"path".as_slice(), b"leaf_value".as_slice())],
        );

        let diff_stream =
            DiffMerkleKeyValueStreams::new(m1.nodestore(), m2.nodestore(), Key::default());

        let results: Vec<_> = diff_stream.collect::<Result<Vec<_>, _>>().unwrap();

        // Should find:
        // - Deletion of path/file1 and path/file2
        // - Addition of path (leaf)
        assert!(
            results.len() >= 2,
            "Should find multiple differences for branch vs leaf"
        );

        println!(
            " Branch vs leaf transitions test passed with {} operations",
            results.len()
        );
    }

    #[test_case(true, false, 0, 1)] // same value, m1->m2: no put needed, delete prefix/b
    #[test_case(false, false, 1, 1)] // diff value, m1->m2: put prefix/a, delete prefix/b
    #[test_case(true, true, 1, 0)] // same value, m2->m1: no change to prefix/a, add prefix/b
    #[test_case(false, true, 2, 0)] // diff value, m2->m1: update prefix/a, add prefix/b
    fn test_branch_vs_leaf_empty_partial_path_bug(
        same_value: bool,
        backwards: bool,
        expected_puts: usize,
        expected_deletes: usize,
    ) {
        // This test covers the exclusion logic in Branch vs Leaf scenarios.
        // It creates a case where one tree has a branch with children, and the other
        // tree has a leaf that matches one of those children - testing that the
        // matching child gets excluded from deletion and properly compared instead.
        //
        // Parameters:
        // - same_value: whether prefix/a has the same value in both trees
        // - backwards: whether to compare m2->m1 instead of m1->m2
        // - expected_puts/expected_deletes: expected operation counts

        // Tree1: Create children under "prefix" but no value at "prefix" itself
        // This creates a branch node at "prefix" with value=None
        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"prefix/a".as_slice(), b"value_a".as_slice()),
                (b"prefix/b".as_slice(), b"value_b".as_slice()),
            ],
        );

        // Tree2: Create just a single value at "prefix/a"
        // Value depends on same_value parameter
        let m2_value: &[u8] = if same_value {
            b"value_a"
        } else {
            b"prefix_a_value"
        };
        let m2 = populate_merkle(create_test_merkle(), &[(b"prefix/a".as_slice(), m2_value)]);

        // Choose direction based on backwards parameter
        let (tree_left, tree_right, direction_desc) = if backwards {
            (m2.nodestore(), m1.nodestore(), "m2->m1")
        } else {
            (m1.nodestore(), m2.nodestore(), "m1->m2")
        };

        let diff_stream = DiffMerkleKeyValueStreams::new(tree_left, tree_right, Key::default());
        let results: Vec<_> = diff_stream.collect::<Result<Vec<_>, _>>().unwrap();

        let delete_count = results
            .iter()
            .filter(|op| matches!(op, BatchOp::Delete { .. }))
            .count();

        let put_count = results
            .iter()
            .filter(|op| matches!(op, BatchOp::Put { .. }))
            .count();

        // Verify against expected counts
        assert_eq!(
            put_count, expected_puts,
            "Put count mismatch for {} (same_value={}, backwards={}), results={results:x?}",
            direction_desc, same_value, backwards
        );
        assert_eq!(
            delete_count, expected_deletes,
            "Delete count mismatch for {} (same_value={}, backwards={}), results={results:x?}",
            direction_desc, same_value, backwards
        );
        assert_eq!(
            results.len(),
            expected_puts + expected_deletes,
            "Total operation count mismatch for {} (same_value={}, backwards={}), results={results:x?}",
            direction_desc,
            same_value,
            backwards
        );

        println!(
            " Branch vs leaf test passed: {} (same_value={}, backwards={}) - {} puts, {} deletes",
            direction_desc, same_value, backwards, put_count, delete_count
        );
    }
}
