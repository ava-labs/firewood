// Copyright (C) 2023, Ava Labs, Inc. All rights reserved.
// See the file LICENSE.md for licensing terms.

#![allow(dead_code)]
// Allow clippy warnings that are generated by the derivative crate's code generation.
// The derivative crate generates Debug implementations that trigger these warnings,
// but we can't control the generated code and these patterns are necessary for the crate to work.
#![allow(clippy::borrowed_box)] // Derivative generates &Box<T> patterns
#![allow(clippy::needless_lifetimes)] // Derivative generates explicit lifetimes that clippy thinks are unnecessary

use firewood_storage::{BranchNode, Child, FileIoError, LeafNode, Node, Path, SharedNode, TrieReader, logger::trace};
use std::cmp::Ordering;
use std::fmt;

use crate::db::BatchOp;
use crate::iter::MerkleKeyValueIter;
use crate::merkle::{Key, Value};
use crate::iter::{IterationNode, NodeIterState, get_iterator_intial_state};
// Local helpers adapted from the iterator module since we can't import private items.
#[cfg(feature = "branch_factor_256")]
fn key_from_nibble_iter<Iter: Iterator<Item = u8>>(nibbles: Iter) -> Key {
    nibbles.collect()
}

#[cfg(not(feature = "branch_factor_256"))]
fn key_from_nibble_iter<Iter: Iterator<Item = u8>>(mut nibbles: Iter) -> Key {
    let mut data = Vec::with_capacity(nibbles.size_hint().0 / 2);
    while let (Some(hi), Some(lo)) = (nibbles.next(), nibbles.next()) {
        let byte = hi
            .checked_shl(4)
            .and_then(|v| v.checked_add(lo))
            .expect("Nibble overflow while constructing byte");
        data.push(byte);
    }
    data.into_boxed_slice()
}

fn as_enumerated_children_iter(
    branch: &BranchNode,
) -> impl Iterator<Item = (u8, Child)> + use<> {
    branch
        .children
        .clone()
        .into_iter()
        .filter_map(|(pos, child)| child.map(|child| (pos.as_u8(), child)))
}

struct PrefixOverlap<'a> {
    unique_a: &'a [u8],
    unique_b: &'a [u8],
}

impl<'a> PrefixOverlap<'a> {
    fn new(a: &'a [u8], b: &'a [u8]) -> Self {
        let split_index = a
            .iter()
            .zip(b.iter())
            .position(|(x, y)| x != y)
            .unwrap_or_else(|| a.len().min(b.len()));
        let unique_a = &a[split_index..];
        let unique_b = &b[split_index..];
        Self { unique_a, unique_b }
    }
}
use derive_more::derive::Debug;
use std::cell::RefCell;

#[derive(Debug, Default, Clone)]
struct DiffStats {
    total_ops_put: u64,
    total_ops_delete: u64,
    left_only_nodes: u64,
    right_only_nodes: u64,
    branch_partial_mismatch: u64,
    pairs_compared: u64,
    nodes_skipped_by_hash: u64,
    max_stack_depth: u32,
}

thread_local! {
    static DIFF_STATS: RefCell<DiffStats> = RefCell::new(DiffStats::default());
}

fn stats_reset() {
    DIFF_STATS.with(|s| *s.borrow_mut() = DiffStats::default());
}
fn stats_snapshot() -> DiffStats {
    DIFF_STATS.with(|s| s.borrow().clone())
}
fn stats_inc<F: FnOnce(&mut DiffStats)>(f: F) {
    DIFF_STATS.with(|s| f(&mut *s.borrow_mut()))
}

fn trim_leaf_node_prefix(node: &SharedNode, prefix_len: usize) -> SharedNode {
    match &**node {
        Node::Leaf(leaf) if prefix_len > 0 => {
            let skip = prefix_len.min(leaf.partial_path.len());
            let trimmed_path = Path::from_nibbles_iterator(
                leaf.partial_path.iter().copied().skip(skip),
            );
            SharedNode::new(Node::Leaf(LeafNode {
                partial_path: trimmed_path,
                value: leaf.value.clone(),
            }))
        }
        _ => node.clone(),
    }
}

fn structural_diff_enabled() -> bool {
    std::env::var("FWD_DIFF_STRUCTURAL")
        .map(|v| v == "1" || v.eq_ignore_ascii_case("true"))
        .unwrap_or(false)
}

// State structs for different types of diff iteration nodes

/// Two nodes that need to be compared against each other.
/// This state occurs when we have matching children in both trees that need to be processed,
/// or when we're starting the comparison at the root level with nodes from both trees.
///
/// The "unvisited" part means that we haven't actually consumed the value
/// in a branch, or we haven't consumed the value of the leaf.
#[derive(Debug)]
struct UnvisitedNodePairState {
    node_left: SharedNode,
    node_right: SharedNode,
}

/// A node that exists only in the left tree (tree1) and needs to be processed for deletion.
/// This state occurs when comparing children and the left tree has a child at a position
/// where the right tree doesn't, or when the entire left subtree needs to be deleted.
#[derive(Debug)]
struct UnvisitedNodeLeftState {
    node: SharedNode,
    excluded_node: Option<(SharedNode, Path)>,
}

/// A node that exists only in the right tree (tree2) and needs to be processed for addition.
/// This state occurs when comparing children and the right tree has a child at a position
/// where the left tree doesn't, or when the entire right subtree needs to be added.
#[derive(Debug)]
struct UnvisitedNodeRightState {
    node: SharedNode,
    excluded_node: Option<(SharedNode, Path)>,
}

/// Two branch nodes whose children are being compared.
/// This state occurs when we have branch nodes from both trees and we need to iterate
/// through their children to find differences between the subtrees.
#[derive(Debug)]
struct VisitedNodePairState {
    #[debug("<iterator>")]
    children_iter_left: Box<dyn Iterator<Item = (u8, Child)> + Send>,
    #[debug("<iterator>")]
    children_iter_right: Box<dyn Iterator<Item = (u8, Child)> + Send>,
}

/// A branch node from the left tree only, whose children all need to be processed as deletions.
/// This state occurs when there are no remaining children on the right side to compare against,
/// or when we have a branch node that exists only in the left tree.
///
/// If `included_node` is Some, one child that matches the included node should be compared
/// instead of deleted (used in Branch vs Leaf scenarios).
///
/// This is always a leaf node (never a branch) because it comes from Branch vs Leaf scenarios
/// where we're traversing a branch's children but need to include any child that represents
/// the same logical key as a leaf from the other tree.
#[derive(Debug)]
struct VisitedNodeLeftState {
    #[debug("<iterator>")]
    children_iter: Box<dyn Iterator<Item = (u8, Child)> + Send>,
    /// Optional included node - if present, children matching this should be compared instead of deleted.
    excluded: Option<(SharedNode, Path)>,
}

/// A branch node from the right tree only, whose children all need to be processed as additions.
/// This state occurs when there are no remaining children on the left side to compare against,
/// or when we have a branch node that exists only in the right tree.
#[derive(Debug)]
struct VisitedNodeRightState {
    #[debug("<iterator>")]
    children_iter: Box<dyn Iterator<Item = (u8, Child)> + Send>,
    /// Optional excluded node - if present, children matching this should be compared instead of added.
    excluded: Option<(SharedNode, Path)>,
}

// Helper function for derivative to format iterators
fn fmt_as_iterator<T>(_: &T, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    f.write_str("\"<iterator>\"")
}

trait StateVisitor {
    fn visit<L: TrieReader, R: TrieReader>(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError>;
}

trait UnvisitedStateVisitor {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError>;
}

/// Trait for processing out-of-sync states that need separate stream processing
trait OutOfSyncStateVisitor {
    fn visit<L: TrieReader, R: TrieReader>(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError>;
}

#[derive(Debug, Default)]
struct IterStack {
    stack: Vec<DiffIterationNode>,
}

impl IterStack {
    fn push(&mut self, node: DiffIterationNode) {
        trace!(
            "pushing new state {{ key: {:x?}, state: {:?} }}",
            node.key, node.state
        );
        if node.key.starts_with(&[0, 7, 7]) {
            trace!("found key {:x?}", node.key);
        }
        self.stack.push(node);
    }
}

impl std::ops::Deref for IterStack {
    type Target = Vec<DiffIterationNode>;

    fn deref(&self) -> &Self::Target {
        &self.stack
    }
}

impl std::ops::DerefMut for IterStack {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.stack
    }
}

// This is the initial state for comparing two nodes. They are unvisited.
// For branches, this means we haven't looked at the k/v pair in the branch
// nor have we looked at any of the children.
// For leaves, this means we haven't looked at the k/v pair in the leaf.

// There are 4 possibilities:
// 1. Both nodes are branches:
// .  Process the branch k/v, then transition to VisitedPairState
// 2. Both nodes are leaves:
// .  Process the leaf k/v, then pop the stack
// 3. Left node is a branch, right node is a leaf:
// .  Compare the branch k/v with the leaf k/v. If they have the same
// .  partial path, then everything except for this leaf is deleted,
// .  and we transition to VisitedLeftState with the leaf excluded
// 4. Left node is a leaf, right node is a branch:
// .  Compare the leaf k/v with the branch k/v. If they have the same
// .  partial path, then everything except for this leaf is added,
// .  and we transition to VisitedRightState with the leaf excluded
#[allow(clippy::too_many_lines)] // for now
impl UnvisitedStateVisitor for UnvisitedNodePairState {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError> {

        trace!(
            "visiting Unvisited node pair at {key:x?} (depth: {})",
            iter_stack.len()
        );
        stats_inc(|s| s.pairs_compared += 1);

        match (&*self.node_left, &*self.node_right) {
            (Node::Branch(branch_left), Node::Branch(branch_right)) => {
                // Possibilities are:
                // (A) The right partial path extends the left partial path
                // (B) The left partial path extends the right partial path
                // (C) Neither extend each other, but left < right
                // (D) Neither extend each other, but left > right
                // (E) The partial paths are the same
                //
                // Case (A):
                // x and y (and any value in branch1) have been deleted
                //
                //   left          right
                //    ...          ...
                //     |            |
                //   branch1       branch2
                //   / | \          ...
                //  x  y  branch2
                //           ...
                // If branch2 is not present on the left, it must be marked added
                // at the appropriate point while traversing left
                //
                // Case (B)
                // x and y (and any value in branch1) have been added
                //
                //  left          right
                //   ...          ...
                //    |            |
                //  branch2       branch1
                //   ...           / | \
                //                x  y  branch2
                //                       ...
                //
                // If branch2 is not present on the right, it must be marked deleted
                // at the appropriate point while traversing right.
                //
                // In both (C) and (D), all the keys on either side do not overlap, but since
                // we must iterate in order:
                // Case (C) deletes all the keys on the left then adds all the keys on the right
                // If present, a value in the left branch was deleted, and added for the right branch
                // Case (D) adds all the keys on the right then deletes all the keys on the left
                // If present, a value in the right branch was added, and deleted for the right branch
                //
                if branch_left.partial_path != branch_right.partial_path {
                    stats_inc(|s| s.branch_partial_mismatch += 1);
                    // Structural mismatch: handle prefix relationships precisely, else process disjoint subtrees in order.
                    trace!(
                        "Partial paths differ at key {:x?}: left={:x?}, right={:x?}",
                        key, branch_left.partial_path, branch_right.partial_path
                    );

                    let node_key_left = Path::from_nibbles_iterator(
                        key.iter()
                            .copied()
                            .chain(branch_left.partial_path.iter().copied()),
                    );
                    let node_key_right = Path::from_nibbles_iterator(
                        key.iter()
                            .copied()
                            .chain(branch_right.partial_path.iter().copied()),
                    );

                    let overlap = PrefixOverlap::new(&branch_left.partial_path.0, &branch_right.partial_path.0);
                    if overlap.unique_a.is_empty() {
                        // Left partial path is a prefix of right: traverse left children, excluding the right node's next nibble
                        let next_b = overlap.unique_b[0];
                        let excluded_path = Path::from_nibbles_iterator(
                            node_key_left.iter().copied().chain(std::iter::once(next_b)),
                        );
                        iter_stack.push(DiffIterationNode {
                            key: node_key_left.clone(),
                            state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                                children_iter: Box::new(as_enumerated_children_iter(branch_left)),
                                excluded: Some((self.node_right.clone(), excluded_path)),
                            }),
                        });
                        // If left had a value at this node, it's deleted at this key
                        if branch_left.value.is_some() {
                            return Ok(Some(BatchOp::Delete { key: key_from_nibble_iter(node_key_left.iter().copied()) }));
                        }
                        return Ok(None);
                    }
                    if overlap.unique_b.is_empty() {
                        // Right partial path is a prefix of left: traverse right children, excluding the left node's next nibble
                        let next_a = overlap.unique_a[0];
                        let excluded_path = Path::from_nibbles_iterator(
                            node_key_right.iter().copied().chain(std::iter::once(next_a)),
                        );
                        iter_stack.push(DiffIterationNode {
                            key: node_key_right.clone(),
                            state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                                children_iter: Box::new(as_enumerated_children_iter(branch_right)),
                                excluded: Some((self.node_left.clone(), excluded_path)),
                            }),
                        });
                        // If right had a value at this node, it's added at this key
                        if let Some(v) = &branch_right.value {
                            return Ok(Some(BatchOp::Put { key: key_from_nibble_iter(node_key_right.iter().copied()), value: v.clone() }));
                        }
                        return Ok(None);
                    }

                    // Disjoint: process entire left then right (or vice versa) based on lexicographic order
                    if node_key_left <= node_key_right {
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                                node: self.node_right,
                                excluded_node: None,
                            }),
                        });
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                                node: self.node_left,
                                excluded_node: None,
                            }),
                        });
                    } else {
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                                node: self.node_left,
                                excluded_node: None,
                            }),
                        });
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                                node: self.node_right,
                                excluded_node: None,
                            }),
                        });
                    }
                    return Ok(None);
                }

                // Case (E) -- Partial paths match, proceed with normal comparison
                // Compute full key at this node (parent key + this node's partial path)
                let node_key = Path::from_nibbles_iterator(
                    key.iter()
                        .copied()
                        .chain(branch_left.partial_path.iter().copied()),
                );

                // Compare values first using the full key
                let value_diff = match (&branch_left.value, &branch_right.value) {
                    (Some(v_left), Some(v_right)) if v_left == v_right => None,
                    (Some(_), None) => Some(BatchOp::Delete {
                        key: key_from_nibble_iter(node_key.iter().copied()),
                    }),
                    (_, Some(v_right)) => Some(BatchOp::Put {
                        key: key_from_nibble_iter(node_key.iter().copied()),
                        value: v_right.clone(),
                    }),
                    (None, None) => None,
                };

                // Set up to compare children
                iter_stack.push(DiffIterationNode {
                    key: node_key,
                    state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                        children_iter_left: Box::new(as_enumerated_children_iter(branch_left)),
                        children_iter_right: Box::new(as_enumerated_children_iter(branch_right)),
                    }),
                });

                Ok(value_diff)
            }
            (Node::Branch(branch), Node::Leaf(leaf)) => {
                // Branch is from left tree, leaf is from right tree
                // This means all (except possibly one) of the k/v pairs
                // on this branch have been deleted.

                // This leaf, however, is special. If it matches some key in the branch,
                // and contains the same value as the leaf, then no diff is needed.
                // If it is found, but doesn't have the same value, we generate a put
                // operation with the leaf's value. We save this leaf into the
                // VisitedNodeLeftState structure and follow the logic there.

                // rare case: the branch itself represents the same logical key as the leaf
                if branch.partial_path == leaf.partial_path {
                    // Full key at this node
                    let node_key = Path::from_nibbles_iterator(
                        key.iter()
                            .copied()
                            .chain(branch.partial_path.iter().copied()),
                    );
                    trace!("branch vs leaf, same path {key:x?}");
                    // continue with all remaining children as deletions, with no
                    // special handling for this leaf, since it's value is in the branch
                    iter_stack.push(DiffIterationNode {
                        key: node_key.clone(),
                        state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                            children_iter: Box::new(as_enumerated_children_iter(branch)),
                            excluded: None,
                        }),
                    });
                    return if let Some(branch_val) = &branch.value {
                        // If the branch value also matches, we can just forget about this leaf
                        if branch_val == &leaf.value {
                            Ok(None)
                        } else {
                            // the branch has a different value, so we need to generate a put
                            // operation for the leaf
                            Ok(Some(BatchOp::Put {
                                key: key_from_nibble_iter(node_key.iter().copied()),
                                value: leaf.value.clone(),
                            }))
                        }
                    } else {
                        // the branch has no value, so the leaf is new, and we need to process the
                        // remaining items on the branch as deletes
                        Ok(Some(BatchOp::Put {
                            key: key_from_nibble_iter(node_key.iter().copied()),
                            value: leaf.value.clone(),
                        }))
                    };
                }
                // Compute full branch key at this node
                let node_key = Path::from_nibbles_iterator(
                    key.iter().copied().chain(branch.partial_path.iter().copied()),
                );

                // If branch path is a prefix of leaf path, exclude the matching child under the branch
                let overlap = PrefixOverlap::new(&branch.partial_path.0, &leaf.partial_path.0);
                if overlap.unique_a.is_empty() && !overlap.unique_b.is_empty() {
                    let next_b = overlap.unique_b[0];
                    let excluded_path = Path::from_nibbles_iterator(
                        node_key.iter().copied().chain(std::iter::once(next_b)),
                    );
                    let trim_len = branch.partial_path.len().saturating_add(1);
                    let trimmed_right = trim_leaf_node_prefix(&self.node_right, trim_len);
                    iter_stack.push(DiffIterationNode {
                        key: node_key.clone(),
                        state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                            children_iter: Box::new(as_enumerated_children_iter(branch)),
                            excluded: Some((trimmed_right, excluded_path)),
                        }),
                    });
                    if branch.value.is_some() {
                        return Ok(Some(BatchOp::Delete {
                            key: key_from_nibble_iter(node_key.iter().copied()),
                        }));
                    }
                    return Ok(None);
                }

                // Otherwise treat as disjoint: delete branch subtree and add leaf in lexicographic order
                let leaf_key = Path::from_nibbles_iterator(
                    key.iter().copied().chain(leaf.partial_path.iter().copied()),
                );
                if node_key <= leaf_key {
                    iter_stack.push(DiffIterationNode {
                        key: leaf_key,
                        state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                            node: self.node_right,
                            excluded_node: None,
                        }),
                    });
                    iter_stack.push(DiffIterationNode {
                        key: node_key,
                        state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                            node: self.node_left,
                            excluded_node: None,
                        }),
                    });
                } else {
                    iter_stack.push(DiffIterationNode {
                        key: node_key,
                        state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                            node: self.node_left,
                            excluded_node: None,
                        }),
                    });
                    iter_stack.push(DiffIterationNode {
                        key: leaf_key,
                        state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                            node: self.node_right,
                            excluded_node: None,
                        }),
                    });
                }
                Ok(None)
            }
            (Node::Leaf(leaf), Node::Branch(branch)) => {
                // Leaf vs Branch - save the leaf and traverse branch children with exclusion
                // Leaf is from left tree, branch is from right tree

                // Compute full branch key at this node
                let branch_key = Path::from_nibbles_iterator(
                    key.iter().copied().chain(branch.partial_path.iter().copied()),
                );

                // Compare the leaf's value with the branch's own value
                // Only generate operations for actual value differences, not structural changes
                let value_diff = match &branch.value {
                    Some(branch_val) if branch_val == &leaf.value => None, // Same value, no operation needed
                    Some(different_val) => Some(BatchOp::Put {
                        // Branch has different value, update it
                        key: key_from_nibble_iter(branch_key.iter().copied()),
                        value: different_val.clone(),
                    }),
                    None => {
                        // Branch has no value - this might be a structural optimization
                        // The leaf might be represented by one of the branch's children
                        // Don't generate a delete operation unless we're sure the leaf doesn't exist
                        None
                    }
                };

                // If leaf path is a prefix of branch path, exclude the matching child under the right branch
                let overlap = PrefixOverlap::new(&leaf.partial_path.0, &branch.partial_path.0);
                if overlap.unique_a.is_empty() && !overlap.unique_b.is_empty() {
                    let next_b = overlap.unique_b[0];
                    let excluded_path = Path::from_nibbles_iterator(
                        branch_key.iter().copied().chain(std::iter::once(next_b)),
                    );
                    iter_stack.push(DiffIterationNode {
                        key: branch_key.clone(),
                        state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                            children_iter: Box::new(as_enumerated_children_iter(branch)),
                            excluded: Some((self.node_left.clone(), excluded_path)),
                        }),
                    });
                    return Ok(value_diff);
                }

                if overlap.unique_b.is_empty() && !overlap.unique_a.is_empty() {
                    // Branch path is a prefix of the leaf path - exclude the matching child and compare
                    let next_a = overlap.unique_a[0];
                    let excluded_path = Path::from_nibbles_iterator(
                        branch_key.iter().copied().chain(std::iter::once(next_a)),
                    );
                    let trim_len = branch.partial_path.len().saturating_add(1);
                    let trimmed_left = trim_leaf_node_prefix(&self.node_left, trim_len);
                    iter_stack.push(DiffIterationNode {
                        key: branch_key,
                        state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                            children_iter: Box::new(as_enumerated_children_iter(branch)),
                            excluded: Some((trimmed_left, excluded_path)),
                        }),
                    });
                    return Ok(value_diff);
                }

                // Otherwise treat as disjoint in lexicographic order: add branch subtree and delete leaf
                let leaf_full_key = Path::from_nibbles_iterator(
                    key.iter().copied().chain(leaf.partial_path.iter().copied()),
                );
                if leaf_full_key <= branch_key {
                    iter_stack.push(DiffIterationNode {
                        key: branch_key.clone(),
                        state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                            node: self.node_right,
                            excluded_node: None,
                        }),
                    });
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                            node: self.node_left,
                            excluded_node: None,
                        }),
                    });
                } else {
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                            node: self.node_left,
                            excluded_node: None,
                        }),
                    });
                    iter_stack.push(DiffIterationNode {
                        key: branch_key.clone(),
                        state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                            node: self.node_right,
                            excluded_node: None,
                        }),
                    });
                }
                Ok(value_diff)
            }
            (Node::Leaf(leaf1), Node::Leaf(leaf2)) => {
                match leaf1.partial_path.cmp(&leaf2.partial_path) {
                    Ordering::Less => {
                        //    left      right
                        //      A         B
                        // A was deleted, B was added, in that order
                        trace!(
                            "Left leaf is prefix of right leaf at key {:x?}: left={:x?}, right={:x?}",
                            key, leaf1.partial_path, leaf2.partial_path
                        );
                        // push right leaf to process as add later
                        // Build full keys
                            let left_full = Path::from_nibbles_iterator(
                                key.iter()
                                    .copied()
                                    .chain(leaf1.partial_path.iter().copied()),
                            );

                        // Since left_full < right_full, emit delete first, then add will be handled by subsequent states
                        // Queue the right leaf put (use parent base key so partial path is applied once)
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                                node: self.node_right,
                                excluded_node: None,
                            }),
                        });

                        Ok(Some(BatchOp::Delete {
                            key: key_from_nibble_iter(left_full.iter().copied()),
                        }))
                    }
                    Ordering::Greater => {
                        // Right leaf has shorter partial path - it's a prefix of left leaf
                        // This means the right leaf represents a key that is a prefix of the left leaf's key
                        // We need to handle this by treating it as an out-of-sync state
                        trace!(
                            "Right leaf is prefix of left leaf at key {:x?}: left={:x?}, right={:x?}",
                            key, leaf1.partial_path, leaf2.partial_path
                        );
                        let right_full = Path::from_nibbles_iterator(
                            key.iter()
                                .copied()
                                .chain(leaf2.partial_path.iter().copied()),
                        );

                        // Since right_full < left_full, emit the put first, then queue the delete
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                                node: self.node_left,
                                excluded_node: None,
                            }),
                        });

                        Ok(Some(BatchOp::Put {
                            key: key_from_nibble_iter(right_full.iter().copied()),
                            value: leaf2.value.clone(),
                        }))
                    }
                    Ordering::Equal => {
                        // Partial paths are equal - this is the normal case
                        if leaf1.value == leaf2.value {
                            Ok(None)
                        } else {
                            // Build the full key (parent + leaf partial path)
                            let node_key = Path::from_nibbles_iterator(
                                key.iter()
                                    .copied()
                                    .chain(leaf2.partial_path.iter().copied()),
                            );
                            Ok(Some(BatchOp::Put {
                                key: key_from_nibble_iter(node_key.iter().copied()),
                                value: leaf2.value.clone(),
                            }))
                        }
                    }
                }
            }
        }
    }
}

impl UnvisitedStateVisitor for UnvisitedNodeLeftState {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError> {
        let base_key = Path::from_nibbles_iterator(key.iter().copied());

        // Node exists only in tree1 - mark for deletion
        match &*self.node {
            Node::Branch(branch) => {
                let full_key = Path::from_nibbles_iterator(
                    base_key.iter().copied().chain(branch.partial_path.iter().copied()),
                );
                iter_stack.push(DiffIterationNode {
                    key: full_key.clone(),
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: Box::new(as_enumerated_children_iter(branch)),
                        excluded: self.excluded_node,
                    }),
                });

                if branch.value.is_some() {
                    // The key already includes the complete path including partial paths
                    Ok(Some(BatchOp::Delete {
                        key: key_from_nibble_iter(full_key.iter().copied()),
                    }))
                } else {
                    Ok(None)
                }
            }
            Node::Leaf(leaf) => {
                // The key already includes the complete path including partial paths
                let full_key = Path::from_nibbles_iterator(
                    base_key.iter().copied().chain(leaf.partial_path.iter().copied()),
                );
                Ok(Some(BatchOp::Delete {
                    key: key_from_nibble_iter(full_key.iter().copied()),
                }))
            }
        }
    }
}

impl UnvisitedStateVisitor for UnvisitedNodeRightState {
    fn visit(
        self,
        key: &Path,
        iter_stack: &mut IterStack,
    ) -> Result<Option<BatchOp<Key, Value>>, FileIoError> {
        let current_key = Path::from_nibbles_iterator(key.iter().copied());

        // Node exists only in tree2 - mark for addition
        match &*self.node {
            Node::Branch(branch) => {
                // Full key at this branch
                let full_key = Path::from_nibbles_iterator(
                    current_key.iter().copied().chain(branch.partial_path.iter().copied()),
                );
                if std::env::var("FWD_DEBUG_DIFF_OPS").ok().as_deref() == Some("1") {
                    eprintln!(
                        "UR Branch add at base={:?} partial={:?} full={:?} value_present={}",
                        key_from_nibble_iter(current_key.iter().copied()),
                        key_from_nibble_iter(branch.partial_path.iter().copied()),
                        key_from_nibble_iter(full_key.iter().copied()),
                        branch.value.is_some()
                    );
                }

                iter_stack.push(DiffIterationNode {
                    key: full_key.clone(),
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: Box::new(as_enumerated_children_iter(branch)),
                        excluded: self.excluded_node,
                    }),
                });

                if let Some(value) = &branch.value {
                    // The key already includes the complete path including partial paths
                    Ok(Some(BatchOp::Put {
                        key: key_from_nibble_iter(full_key.iter().copied()),
                        value: value.clone(),
                    }))
                } else {
                    Ok(None)
                }
            }
            Node::Leaf(leaf) => {
                let full_key = Path::from_nibbles_iterator(
                    current_key.iter().copied().chain(leaf.partial_path.iter().copied()),
                );
                if std::env::var("FWD_DEBUG_DIFF_OPS").ok().as_deref() == Some("1") {
                    eprintln!(
                        "UR Leaf add at base={:?} partial={:?} full={:?}",
                        key_from_nibble_iter(current_key.iter().copied()),
                        key_from_nibble_iter(leaf.partial_path.iter().copied()),
                        key_from_nibble_iter(full_key.iter().copied()),
                    );
                }
                // The key already includes the complete path including partial paths
                Ok(Some(BatchOp::Put {
                    key: key_from_nibble_iter(full_key.iter().copied()),
                    value: leaf.value.clone(),
                }))
            }
        }
    }
}

impl StateVisitor for VisitedNodeLeftState {
    fn visit<L: TrieReader, R: TrieReader>(
        mut self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError> {
        if let Some((pos, child)) = self.children_iter.next() {
            let node = match child {
                Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                Child::Node(node) => node.clone().into(),
                Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.0)?,
            };

            let child_key_base = Path::from_nibbles_iterator(
                key.iter().copied().chain(std::iter::once(pos)),
            );

            if let Some((excluded_node, excluded_path)) = self.excluded.take() {
                trace!("child_key is {child_key_base:x?}");
                trace!("LS checking....{child_key_base:x?} is excluded...");
                if excluded_path == child_key_base {
                    trace!("yes");
                    // Found the excluded child

                    // resume after the excluded child
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                            children_iter: self.children_iter,
                            excluded: None, // Already taken
                        }),
                    });

                    // Compare this child instead of deleting (using moved excluded_node)
                    iter_stack.push(DiffIterationNode {
                        key: child_key_base,
                        state: DiffIterationNodeState::UnvisitedPair(UnvisitedNodePairState {
                            node_left: node,
                            node_right: excluded_node, // Moved, no clone needed
                        }),
                    });
                } else {
                    // Not the excluded child - put it back and continue looking
                    trace!("no");
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                            children_iter: self.children_iter,
                            excluded: Some((excluded_node.clone(), excluded_path.clone())), // Put it back
                        }),
                    });

                    // Delete this child
                    iter_stack.push(DiffIterationNode {
                        key: child_key_base,
                        state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                            node,
                            excluded_node: Some((excluded_node, excluded_path)),
                        }),
                    });
                }
            } else {
                // No exclusion - delete all children
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: self.children_iter,
                        excluded: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key_base,
                    state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                        node,
                        excluded_node: None,
                    }),
                });
            }
        } else {
            // No more children on the left. If an excluded right node was never matched,
            // it means that node does not exist on the left and must be added now.
            if let Some((excluded_node, excluded_path)) = self.excluded.take() {
                iter_stack.push(DiffIterationNode {
                    key: excluded_path,
                    state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                        node: excluded_node,
                        excluded_node: None,
                    }),
                });
            }
        }
        Ok(())
    }
}

#[allow(clippy::pedantic, clippy::arithmetic_side_effects)]
impl StateVisitor for VisitedNodePairState {
    fn visit<L: TrieReader, R: TrieReader>(
        mut self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError> {
        // Compare children from both trees
        let child_left_opt = self.children_iter_left.next();
        let child_right_opt = self.children_iter_right.next();

        match (child_left_opt, child_right_opt) {
            (Some((pos_left, child_left)), Some((pos_right, child_right))) => {
                match pos_left.cmp(&pos_right) {
                    Ordering::Equal => {
                        // Same position - check if subtrees are identical
                        if DiffMerkleNodeStream::<L, R>::child_identical(&child_left, &child_right) {
                            // Identical subtrees, skip them and continue with remaining children
                            iter_stack.push(DiffIterationNode {
                                key: key.clone(),
                                state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                    children_iter_left: self.children_iter_left,
                                    children_iter_right: self.children_iter_right,
                                }),
                            });
                            return Ok(());
                        }

                        // Different subtrees, need to compare them
                        let node_left = match child_left {
                            Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                            Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.0)?,
                        };

                        let node_right = match child_right {
                            Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                            Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.1)?,
                        };

                        let child_key_base: Path = {
                            let nibbles: Vec<u8> = key
                                .iter()
                                .copied()
                                .chain(std::iter::once(pos_left))
                                .collect();
                            Path::from(nibbles.as_slice())
                        };

                        // Continue with remaining children
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                children_iter_left: self.children_iter_left,
                                children_iter_right: self.children_iter_right,
                            }),
                        });

                        iter_stack.push(DiffIterationNode {
                            key: child_key_base,
                            state: DiffIterationNodeState::UnvisitedPair(UnvisitedNodePairState {
                                node_left,
                                node_right,
                            }),
                        });
                    }
                    Ordering::Less => {
                        // pos_left < pos_right: child exists in tree_left but not tree_right
                        stats_inc(|s| s.left_only_nodes += 1);
                        let node_left = match child_left {
                            Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                            Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.0)?,
                        };

                        let child_key_base: Path = {
                            let nibbles: Vec<u8> = key
                                .iter()
                                .copied()
                                .chain(std::iter::once(pos_left))
                                .collect();
                            Path::from(nibbles.as_slice())
                        };

                        // Put back child_right for next iteration
                        let new_iter_right = std::iter::once((pos_right, child_right))
                            .chain(self.children_iter_right);
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                children_iter_left: self.children_iter_left,
                                children_iter_right: Box::new(new_iter_right),
                            }),
                        });

                        iter_stack.push(DiffIterationNode {
                            key: child_key_base,
                            state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                                node: node_left,
                                excluded_node: None,
                            }),
                        });
                    }
                    Ordering::Greater => {
                        // pos_left > pos_right: child exists in tree_right but not tree_left
                        stats_inc(|s| s.right_only_nodes += 1);
                        let node_right = match child_right {
                            Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                            Child::Node(node) => node.clone().into(),
                            Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.1)?,
                        };

                        let child_key_base: Path = {
                            let nibbles: Vec<u8> = key
                                .iter()
                                .copied()
                                .chain(std::iter::once(pos_right))
                                .collect();
                            Path::from(nibbles.as_slice())
                        };

                        // Put back child_left for next iteration
                        let new_iter_left =
                            std::iter::once((pos_left, child_left)).chain(self.children_iter_left);
                        iter_stack.push(DiffIterationNode {
                            key: key.clone(),
                            state: DiffIterationNodeState::VisitedPair(VisitedNodePairState {
                                children_iter_left: Box::new(new_iter_left),
                                children_iter_right: self.children_iter_right,
                            }),
                        });

                        iter_stack.push(DiffIterationNode {
                            key: child_key_base,
                            state: DiffIterationNodeState::UnvisitedRight(
                                UnvisitedNodeRightState {
                                    node: node_right,
                                    excluded_node: None,
                                },
                            ),
                        });
                    }
                }
            }
            (Some((pos_left, child_left)), None) => {
                // Only tree_left has remaining children
                stats_inc(|s| s.left_only_nodes += 1);
                let node_left = match child_left {
                    Child::AddressWithHash(addr, _) => readers.0.read_node(addr)?,
                    Child::Node(node) => node.clone().into(),
                    Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.0)?,
                };

                let child_key_base: Path = {
                    let nibbles: Vec<u8> = key
                        .iter()
                        .copied()
                        .chain(std::iter::once(pos_left))
                        .collect();
                    Path::from(nibbles.as_slice())
                };

                // Continue with remaining children from tree_left
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: self.children_iter_left,
                        excluded: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key_base,
                    state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                        node: node_left,
                        excluded_node: None,
                    }),
                });
            }
            (None, Some((pos_right, child_right))) => {
                // Only tree_right has remaining children
                stats_inc(|s| s.right_only_nodes += 1);
                let node_right = match child_right {
                    Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                    Child::Node(node) => node.clone().into(),
                    Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.1)?,
                };

                let child_key_base: Path = {
                    let nibbles: Vec<u8> = key
                        .iter()
                        .copied()
                        .chain(std::iter::once(pos_right))
                        .collect();
                    Path::from(nibbles.as_slice())
                };

                // Continue with remaining children from tree_right
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: self.children_iter_right,
                        excluded: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key_base,
                    state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                        node: node_right,
                        excluded_node: None,
                    }),
                });
            }
            (None, None) => {
                // No more children in either tree, continue
            }
        }
        Ok(())
    }
}

impl StateVisitor for VisitedNodeRightState {
    fn visit<L: TrieReader, R: TrieReader>(
        mut self,
        key: &Path,
        iter_stack: &mut IterStack,
        readers: (&L, &R),
    ) -> Result<(), FileIoError> {
        if let Some((pos, child)) = self.children_iter.next() {
            let node = match child {
                Child::AddressWithHash(addr, _) => readers.1.read_node(addr)?,
                Child::Node(node) => node.clone().into(),
                Child::MaybePersisted(maybe, _) => maybe.as_shared_node(readers.1)?,
            };

            let child_key_base =
                Path::from_nibbles_iterator(key.iter().copied().chain(std::iter::once(pos)));

            // Check if this child should be compared instead of added
            if let Some((excluded_node, excluded_path)) = self.excluded.take() {
                trace!("RS checking....{child_key_base:x?} is excluded...");
                if excluded_path == child_key_base {
                    // Found the excluded child - compare instead of adding
                    trace!("yes");
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                            children_iter: self.children_iter,
                            excluded: None,
                        }),
                    });
                    iter_stack.push(DiffIterationNode {
                        key: child_key_base,
                        state: DiffIterationNodeState::UnvisitedPair(UnvisitedNodePairState {
                            node_left: excluded_node,
                            node_right: node,
                        }),
                    });
                } else {
                    // Not the excluded child - add it
                    trace!("no");
                    iter_stack.push(DiffIterationNode {
                        key: key.clone(),
                        state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                            children_iter: self.children_iter,
                            excluded: Some((excluded_node, excluded_path)),
                        }),
                    });
                    iter_stack.push(DiffIterationNode {
                        key: child_key_base,
                        state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                            node,
                            excluded_node: None,
                        }),
                    });
                }
            } else {
                // No inclusion - add all children
                iter_stack.push(DiffIterationNode {
                    key: key.clone(),
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: self.children_iter,
                        excluded: None,
                    }),
                });

                iter_stack.push(DiffIterationNode {
                    key: child_key_base,
                    state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                        node,
                        excluded_node: None,
                    }),
                });
            }
        } else {
            // No more children on the right. If an excluded left node was never matched,
            // it means that node does not exist on the right and must be deleted now.
            if let Some((excluded_node, excluded_path)) = self.excluded.take() {
                iter_stack.push(DiffIterationNode {
                    key: excluded_path,
                    state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                        node: excluded_node,
                        excluded_node: None,
                    }),
                });
            }
        }
        Ok(())
    }
}

/// Enum containing all possible states for a diff iteration node
#[derive(Debug)]
enum DiffIterationNodeState {
    /// Two unvisited nodes that should be compared
    UnvisitedPair(UnvisitedNodePairState),
    /// A node that exists only in tree1 (needs to be deleted)
    UnvisitedLeft(UnvisitedNodeLeftState),
    /// A node that exists only in tree2 (needs to be added)
    UnvisitedRight(UnvisitedNodeRightState),
    /// A pair of visited branch nodes - track which children to compare next
    VisitedPair(VisitedNodePairState),
    /// A visited branch node from tree1 only (may have exclusions)
    VisitedLeft(VisitedNodeLeftState),
    /// A visited branch node from tree2 only (may have exclusions)
    VisitedRight(VisitedNodeRightState),
}

/// Iteration node that tracks state for both trees simultaneously
#[derive(Debug)]
struct DiffIterationNode {
    key: Path,
    state: DiffIterationNodeState,
}

impl DiffIterationNode {
    /// Convert an `IterationNode` to a `DiffIterationNode` for left tree operations (deletions).
    fn from_left(node: IterationNode) -> Self {
        match node {
            IterationNode::Unvisited { key, node } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::UnvisitedLeft(UnvisitedNodeLeftState {
                        node,
                        excluded_node: None,
                    }),
                }
            }
            IterationNode::Visited { key, children_iter } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::VisitedLeft(VisitedNodeLeftState {
                        children_iter: Box::new(children_iter.map(|(pc, child)| (pc.as_u8(), child))),
                        excluded: None,
                    }),
                }
            }
        }
    }

    /// Convert an `IterationNode` to a `DiffIterationNode` for right tree operations (additions).
    fn from_right(node: IterationNode) -> Self {
        match node {
            IterationNode::Unvisited { key, node } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::UnvisitedRight(UnvisitedNodeRightState {
                        node,
                        excluded_node: None,
                    }),
                }
            }
            IterationNode::Visited { key, children_iter } => {
                let path = Path::from(key.as_ref());
                DiffIterationNode {
                    key: path,
                    state: DiffIterationNodeState::VisitedRight(VisitedNodeRightState {
                        children_iter: Box::new(children_iter.map(|(pc, child)| (pc.as_u8(), child))),
                        excluded: None,
                    }),
                }
            }
        }
    }
}

/// State for the diff iterator that tracks lazy initialization
#[derive(Debug)]
enum DiffNodeStreamState {
    /// The iterator state is lazily initialized when `next_internal` is called
    /// for the first time. The iteration start key is stored here.
    StartFromKey(Key),
    /// The iterator is actively iterating over nodes
    Iterating { iter_stack: IterStack },
}

impl From<Key> for DiffNodeStreamState {
    fn from(key: Key) -> Self {
        Self::StartFromKey(key)
    }
}

#[derive(Debug)]
struct BothIters<'a, T: TrieReader, U: TrieReader> {
    left: MerkleKeyValueIter<'a, T>,
    right: MerkleKeyValueIter<'a, U>,
    peek_left: Option<Result<(Key, Value), crate::v2::api::Error>>,
    peek_right: Option<Result<(Key, Value), crate::v2::api::Error>>,
}

impl<'a, T: TrieReader, U: TrieReader> BothIters<'a, T, U> {
    fn new(tree_left: &'a T, tree_right: &'a U, start_key: &Key) -> Self {
        let mut left = MerkleKeyValueIter::from_key(tree_left, start_key);
        let mut right = MerkleKeyValueIter::from_key(tree_right, start_key);
        let peek_left = left.next();
        let peek_right = right.next();
        Self { left, right, peek_left, peek_right }
    }

    fn next_op(&mut self) -> Option<Result<BatchOp<Key, Value>, firewood_storage::FileIoError>> {
        use firewood_storage::FileIoError;
        match (self.peek_left.take(), self.peek_right.take()) {
            (None, None) => None,
            (Some(Err(e)), _) | (_, Some(Err(e))) => Some(Err(FileIoError::from_generic_no_file(std::io::Error::other(e.to_string()), "diff both iters"))),
            (Some(Ok((lk, _lv))), None) => {
                self.peek_left = self.left.next();
                Some(Ok(BatchOp::Delete { key: lk }))
            }
            (None, Some(Ok((rk, rv)))) => {
                self.peek_right = self.right.next();
                Some(Ok(BatchOp::Put { key: rk, value: rv }))
            }
            (Some(Ok((lk, lv))), Some(Ok((rk, rv)))) => match lk.cmp(&rk) {
                Ordering::Equal => {
                    self.peek_left = self.left.next();
                    self.peek_right = self.right.next();
                    if lv == rv {
                        self.next_op()
                    } else {
                        Some(Ok(BatchOp::Put { key: rk, value: rv }))
                    }
                }
                Ordering::Less => {
                    self.peek_right = Some(Ok((rk, rv)));
                    self.peek_left = self.left.next();
                    Some(Ok(BatchOp::Delete { key: lk }))
                }
                Ordering::Greater => {
                    self.peek_left = Some(Ok((lk, lv)));
                    self.peek_right = self.right.next();
                    Some(Ok(BatchOp::Put { key: rk, value: rv }))
                }
            },
        }
    }
}

#[derive(derive_more::Debug)]
enum UniCase<'a, T: TrieReader, U: TrieReader> {
    #[debug("both")] Both,
    #[debug("both_iters")] BothIters(BothIters<'a, T, U>),
    #[debug("right_iter")] Right(MerkleKeyValueIter<'a, U>),
    #[debug("left_iter")] Left(MerkleKeyValueIter<'a, T>),
}

#[derive(derive_more::Debug)]
struct DiffMerkleNodeStream<'a, T: TrieReader, U: TrieReader> {
    tree_left: &'a T,
    tree_right: &'a U,
    state: DiffNodeStreamState,
    #[debug("<uni_case>")]
    uni_case: UniCase<'a, T, U>,
    path_kind: DiffPathKind,
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum DiffPathKind {
    Structural,
    Simple,
}

impl<'a, T: TrieReader, U: TrieReader> DiffMerkleNodeStream<'a, T, U> {
    fn new(tree_left: &'a T, tree_right: &'a U, start_key: Key) -> Self {
        stats_reset();
        // Determine if one side is empty for optimized traversal
        let left_empty = tree_left.root_node().is_none();
        let right_empty = tree_right.root_node().is_none();
        let use_structural = structural_diff_enabled();
        let (uni_case, path_kind) = if left_empty && !right_empty {
            (
                UniCase::Right(MerkleKeyValueIter::from_key(tree_right, &start_key)),
                DiffPathKind::Simple,
            )
        } else if !left_empty && right_empty {
            (
                UniCase::Left(MerkleKeyValueIter::from_key(tree_left, &start_key)),
                DiffPathKind::Simple,
            )
        } else if use_structural {
            (
                UniCase::Both,
                DiffPathKind::Structural,
            )
        } else {
            (
                UniCase::BothIters(BothIters::new(tree_left, tree_right, &start_key)),
                DiffPathKind::Simple,
            )
        };

        Self {
            tree_left,
            tree_right,
            state: DiffNodeStreamState::from(start_key),
            uni_case,
            path_kind,
        }
    }

    #[cfg(test)]
    fn new_simple(tree_left: &'a T, tree_right: &'a U, start_key: Key) -> Self {
        stats_reset();
        Self {
            tree_left,
            tree_right,
            state: DiffNodeStreamState::from(start_key.clone()),
            uni_case: UniCase::BothIters(BothIters::new(tree_left, tree_right, &start_key)),
            path_kind: DiffPathKind::Simple,
        }
    }

    /// Check if two children have the same hash or refer to the same node.
    ///
    /// This is used to determine if two subtrees are identical.
    ///
    /// For mutable trees, we can compare node addresses to detect identical subtrees
    /// This works because identical subtrees will share the same underlying Node reference
    /// For immutable trees, we can't know if they are the same, assume not
    fn child_identical(child_left: &Child, child_right: &Child) -> bool {
        match (child_left, child_right) {
            (Child::AddressWithHash(_, hash_left), Child::AddressWithHash(_, hash_right)) => {
                hash_left == hash_right
            }
            // At least one of the children is unhashed, so we can't know if they are the same, assume not
            _ => false,
        }
    }

    /// Returns the initial state for a diff iterator over the given trees which starts at `key`.
    fn get_diff_iterator_initial_state(
        tree_left: &T,
        tree_right: &U,
        key: &[u8],
    ) -> Result<DiffNodeStreamState, firewood_storage::FileIoError> {
        let root_left_opt = tree_left.root_node();
        let root_right_opt = tree_right.root_node();

        match (root_left_opt, root_right_opt) {
            (None, None) => {
                // Both trees are empty
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack::default(),
                })
            }
            (Some(_root_left), None) => {
                // Only tree_left has content - use single tree traversal for deletions
                let initial_state = get_iterator_intial_state(tree_left, key)?;
                let iter_stack = match initial_state {
                    NodeIterState::StartFromKey(_) => vec![], // Should not happen
                    NodeIterState::Iterating { iter_stack } => {
                        // Convert IterationNode to DiffIterationNode for left tree operations
                        iter_stack
                            .into_iter()
                            .map(DiffIterationNode::from_left)
                            .collect()
                    }
                };
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack { stack: iter_stack },
                })
            }
            (None, Some(_root_right)) => {
                // Only tree_right has content - use single tree traversal for additions
                let initial_state = get_iterator_intial_state(tree_right, key)?;
                let iter_stack = match initial_state {
                    NodeIterState::StartFromKey(_) => vec![], // Should not happen
                    NodeIterState::Iterating { iter_stack } => {
                        // Convert IterationNode to DiffIterationNode for right tree operations
                        let v: Vec<_> = iter_stack
                            .into_iter()
                            .map(DiffIterationNode::from_right)
                            .collect();
                        #[cfg(test)]
                        {
                            for n in &v {
                                println!(
                                    "DEBUG init right-only stack key={:?}",
                                    key_from_nibble_iter(n.key.iter().copied())
                                );
                            }
                        }
                        v
                    }
                };
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack { stack: iter_stack },
                })
            }
            (Some(root_left), Some(root_right)) => {
                // Both trees have content - need to compare them
                // Start with an empty path and let the node comparison logic handle partial paths
                // This ensures we don't double-add partial paths from different roots
                let root_key: Path = Path::from_nibbles_iterator(std::iter::empty());
                Ok(DiffNodeStreamState::Iterating {
                    iter_stack: IterStack {
                        stack: vec![DiffIterationNode {
                            key: root_key,
                            state: DiffIterationNodeState::UnvisitedPair(UnvisitedNodePairState {
                                node_left: root_left,
                                node_right: root_right,
                            }),
                        }],
                    },
                })
            }
        }
    }

    fn next_internal(
        &mut self,
    ) -> Option<Result<BatchOp<Key, Value>, firewood_storage::FileIoError>> {
        // Fast-path for single-tree traversal
        match &mut self.uni_case {
            UniCase::Right(iter) => {
                if let Some(next) = iter.next() {
                    return Some(match next {
                        Ok((key, value)) => Ok(BatchOp::Put { key, value }),
                        Err(e) => Err(firewood_storage::FileIoError::from_generic_no_file(
                            std::io::Error::other(e.to_string()),
                            "diff uni right",
                        )),
                    });
                } else {
                    return None;
                }
            }
            UniCase::Left(iter) => {
                if let Some(next) = iter.next() {
                    return Some(match next {
                        Ok((key, _value)) => Ok(BatchOp::Delete { key }),
                        Err(e) => Err(firewood_storage::FileIoError::from_generic_no_file(
                            std::io::Error::other(e.to_string()),
                            "diff uni left",
                        )),
                    });
                } else {
                    return None;
                }
            }
            UniCase::Both => {}
            UniCase::BothIters(b) => {
                return b.next_op();
            }
        }
        // Handle lazy initialization
        let iter_stack = match &mut self.state {
            DiffNodeStreamState::StartFromKey(key) => {
                match Self::get_diff_iterator_initial_state(self.tree_left, self.tree_right, key) {
                    Ok(new_state) => {
                        self.state = new_state;
                        return self.next_internal();
                    }
                    Err(e) => return Some(Err(e)),
                }
            }
            DiffNodeStreamState::Iterating { iter_stack } => iter_stack,
        };

        // We remove the most recent DiffIterationNode, but in some cases we will push it back onto the stack.
        // Track max stack depth for stats using current stack's length.
        stats_inc(|s| s.max_stack_depth = s.max_stack_depth.max(iter_stack.len() as u32));
        while let Some(iter_node) = iter_stack.pop() {
            match iter_node.state {
                DiffIterationNodeState::UnvisitedPair(state) => {
                    match state.visit(&iter_node.key, iter_stack) {
                        Ok(Some(result)) => return Some(Ok(result)),
                        Ok(None) => {}
                        Err(e) => return Some(Err(e)),
                    }
                }
                DiffIterationNodeState::UnvisitedLeft(state) => {
                    match state.visit(&iter_node.key, iter_stack) {
                        Ok(Some(result)) => return Some(Ok(result)),
                        Ok(None) => {}
                        Err(e) => return Some(Err(e)),
                    }
                }
                DiffIterationNodeState::UnvisitedRight(state) => {
                    match state.visit(&iter_node.key, iter_stack) {
                        Ok(Some(result)) => return Some(Ok(result)),
                        Ok(None) => {}
                        Err(e) => return Some(Err(e)),
                    }
                }
                DiffIterationNodeState::VisitedPair(state) => {
                    if let Err(e) = state.visit::<T, U>(
                        &iter_node.key,
                        iter_stack,
                        (self.tree_left, self.tree_right),
                    ) {
                        return Some(Err(e));
                    }
                }
                DiffIterationNodeState::VisitedLeft(state) => {
                    if let Err(e) = state.visit::<T, U>(
                        &iter_node.key,
                        iter_stack,
                        (self.tree_left, self.tree_right),
                    ) {
                        return Some(Err(e));
                    }
                }
                DiffIterationNodeState::VisitedRight(state) => {
                    if let Err(e) = state.visit::<T, U>(
                        &iter_node.key,
                        iter_stack,
                        (self.tree_left, self.tree_right),
                    ) {
                        return Some(Err(e));
                    }
                }
            }
        }
        None
    }
}

impl<T: TrieReader, U: TrieReader> Iterator for DiffMerkleNodeStream<'_, T, U> {
    type Item = Result<BatchOp<Key, Value>, firewood_storage::FileIoError>;

    fn next(&mut self) -> Option<Self::Item> {
        let item = self.next_internal();
        if let Some(Ok(ref op)) = item {
            if std::env::var("FWD_DEBUG_DIFF_OPS").ok().as_deref() == Some("1") {
                let mode = match self.path_kind {
                    DiffPathKind::Structural => "STRUCT",
                    DiffPathKind::Simple => "SIMPLE",
                };
                match op {
                    BatchOp::Put { key, value } => {
                        eprintln!(
                            "[{mode}] OP Put key={:?} len={}",
                            key.as_ref(),
                            value.len()
                        );
                        stats_inc(|s| s.total_ops_put += 1);
                    }
                    BatchOp::Delete { key } => {
                        eprintln!("[{mode}] OP Del key={:?}", key.as_ref());
                        stats_inc(|s| s.total_ops_delete += 1);
                    }
                    BatchOp::DeleteRange { prefix } => {
                        eprintln!("[{mode}] OP DelRange prefix={:?}", prefix.as_ref());
                    }
                }
            }
        }
        if item.is_none() {
            let snap = stats_snapshot();
            if std::env::var("FWD_DIFF_STATS").ok().as_deref() == Some("1") {
                eprintln!(
                    "DIFF STATS: puts={} deletes={} left_only={} right_only={} mismatches={} pairs_compared={} skipped_by_hash={} max_stack_depth={}",
                    snap.total_ops_put,
                    snap.total_ops_delete,
                    snap.left_only_nodes,
                    snap.right_only_nodes,
                    snap.branch_partial_mismatch,
                    snap.pairs_compared,
                    snap.nodes_skipped_by_hash,
                    snap.max_stack_depth,
                );
            }
        }
        item
    }
}

/// Optimized diff stream that uses `DiffMerkleNodeStream` for hash-based optimizations
#[derive(derive_more::Debug)]
struct DiffMerkleKeyValueStreams<'a, T: TrieReader, U: TrieReader> {
    #[debug("<stream>")]
    node_stream: DiffMerkleNodeStream<'a, T, U>,
}

impl<'a, T: TrieReader, U: TrieReader> DiffMerkleKeyValueStreams<'a, T, U> {
    fn new(tree_left: &'a T, tree_right: &'a U, start_key: Key) -> Self {
        Self {
            node_stream: DiffMerkleNodeStream::new(tree_left, tree_right, start_key),
        }
    }
}

impl<T: TrieReader, U: TrieReader> Iterator for DiffMerkleKeyValueStreams<'_, T, U> {
    type Item = Result<BatchOp<Key, Value>, firewood_storage::FileIoError>;

    fn next(&mut self) -> Option<Self::Item> {
        let item = self.node_stream.next_internal();
        if let Some(Ok(ref op)) = item {
            if std::env::var("FWD_DEBUG_DIFF_OPS").ok().as_deref() == Some("1") {
                match op {
                    BatchOp::Put { key, value } => {
                        eprintln!(
                            "OP Put key={:?} len={}",
                            key.as_ref(),
                            value.len()
                        );
                    }
                    BatchOp::Delete { key } => {
                        eprintln!("OP Del key={:?}", key.as_ref());
                    }
                    BatchOp::DeleteRange { prefix } => {
                        eprintln!("OP DelRange prefix={:?}", prefix.as_ref());
                    }
                }
            }
        }
        item
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used)]
mod tests {
    use crate::merkle::Merkle;

    use super::*;
    use env_logger::WriteStyle;
    use firewood_storage::{ImmutableProposal, MemStore, MutableProposal, NodeStore};
    use std::sync::Arc;
    use test_case::test_case;

    fn diff_merkle_iterator<'a, T, U>(
        tree_left: &'a Merkle<T>,
        tree_right: &'a Merkle<U>,
        start_key: Key,
    ) -> DiffMerkleNodeStream<'a, T, U>
    where
        T: firewood_storage::TrieReader,
        U: firewood_storage::TrieReader,
    {
        DiffMerkleNodeStream::new(tree_left.nodestore(), tree_right.nodestore(), start_key)
    }

    fn create_test_merkle() -> Merkle<NodeStore<MutableProposal, MemStore>> {
        let memstore = MemStore::new(vec![]);
        let nodestore = NodeStore::new_empty_proposal(Arc::new(memstore));
        Merkle::from(nodestore)
    }

    fn populate_merkle(
        mut merkle: Merkle<NodeStore<MutableProposal, MemStore>>,
        items: &[(&[u8], &[u8])],
    ) -> Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> {
        for (key, value) in items {
            merkle
                .insert(key, value.to_vec().into_boxed_slice())
                .unwrap();
        }
        merkle.try_into().unwrap()
    }

    fn make_immutable(
        merkle: Merkle<NodeStore<MutableProposal, MemStore>>,
    ) -> Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> {
        merkle.try_into().unwrap()
    }

    #[test]
    fn test_structural_simple_parity_small_random() {
        use rand::rngs::StdRng;
        use rand::{Rng, SeedableRng};

        let _ = env_logger::builder()
            .write_style(WriteStyle::Never)
            .format_timestamp(None)
            .is_test(true)
            .try_init();

        let base_seed = 0xBEEF_F00D_CAFE_BABE_u64;
        let rounds = 10usize;
        let items = 500usize;
        let modify = 150usize;
        for round in 0..rounds {
            let seed = base_seed ^ (round as u64);
            let mut rng = StdRng::seed_from_u64(seed);

            // Unique base
            let mut base: Vec<(Vec<u8>, Vec<u8>)> = Vec::with_capacity(items);
            let mut seen = std::collections::HashSet::new();
            while base.len() < items {
                let klen = rng.random_range(1..=32);
                let vlen = rng.random_range(1..=64);
                let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
                if seen.insert(key.clone()) {
                    let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
                    base.push((key, val));
                }
            }

            let mut left = create_test_merkle();
            let mut right = create_test_merkle();
            for (k, v) in &base {
                left.insert(k, v.clone().into_boxed_slice()).unwrap();
                right.insert(k, v.clone().into_boxed_slice()).unwrap();
            }

            // Modify right
            for _ in 0..modify {
                let idx = rng.random_range(0..base.len());
                match rng.random_range(0..3) {
                    0 => {
                        // delete
                        right.remove(&base[idx].0).ok();
                    }
                    1 => {
                        // update existing
                        if right.get_value(&base[idx].0).unwrap().is_some() {
                            let newlen = rng.random_range(1..=64);
                            let newval: Vec<u8> = (0..newlen).map(|_| rng.random()).collect();
                            right.insert(&base[idx].0, newval.into_boxed_slice()).unwrap();
                        }
                    }
                    _ => {
                        // insert
                        let klen = rng.random_range(1..=32);
                        let vlen = rng.random_range(1..=64);
                        let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
                        let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
                        right.insert(&key, val.into_boxed_slice()).unwrap();
                    }
                }
            }

            // Freeze
            let left_imm = make_immutable(left);
            let right_imm = make_immutable(right);

            // Structural
            let ops_struct = DiffMerkleNodeStream::new(left_imm.nodestore(), right_imm.nodestore(), Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap();
            // Simple oracle
            let ops_simple = DiffMerkleNodeStream::new_simple(left_imm.nodestore(), right_imm.nodestore(), Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap();

            // Apply structural
            let mut fork = left_imm.fork().unwrap();
            for op in &ops_struct {
                match op {
                    BatchOp::Put { key, value } => { fork.insert(key, value.clone()).unwrap(); }
                    BatchOp::Delete { key } => { fork.remove(key).unwrap(); }
                    BatchOp::DeleteRange { prefix } => { fork.remove_prefix(prefix).unwrap(); }
                }
            }
            let after_struct: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> = fork.try_into().unwrap();

            // Apply simple
            let mut fork2 = left_imm.fork().unwrap();
            for op in &ops_simple {
                match op {
                    BatchOp::Put { key, value } => { fork2.insert(key, value.clone()).unwrap(); }
                    BatchOp::Delete { key } => { fork2.remove(key).unwrap(); }
                    BatchOp::DeleteRange { prefix } => { fork2.remove_prefix(prefix).unwrap(); }
                }
            }
            let after_simple: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> = fork2.try_into().unwrap();

            // Compare both results and also to right
            let mut a = crate::iter::MerkleKeyValueIter::from(after_struct.nodestore());
            let mut b = crate::iter::MerkleKeyValueIter::from(after_simple.nodestore());
            let mut r = crate::iter::MerkleKeyValueIter::from(right_imm.nodestore());
            loop {
                match (a.next(), b.next(), r.next()) {
                    (None, None, None) => break,
                    (Some(Ok((ak, av))), Some(Ok((bk, bv))), Some(Ok((rk, rv)))) => {
                        let debug_parity = std::env::var("FWD_DEBUG_PARITY")
                            .ok()
                            .as_deref()
                            == Some("1");
                        if ak != bk && debug_parity {
                            println!(
                                " struct/simple key mismatch seed={seed} round={round}\n  struct={ak:x?}\n  simple={bk:x?}"
                            );
                            println!("  struct.ops:");
                            for op in &ops_struct {
                                println!("    {op:x?}");
                            }
                            println!("  simple.ops:");
                            for op in &ops_simple {
                                println!("    {op:x?}");
                            }
                        }
                        assert_eq!(ak, bk, "parity keys differ seed={seed} round={round}");

                        if av != bv && debug_parity {
                            println!(
                                " struct/simple value mismatch seed={seed} round={round}\n  struct_key={ak:x?}\n  struct_val={av:x?}\n  simple_val={bv:x?}"
                            );
                        }
                        assert_eq!(av, bv, "parity values differ seed={seed} round={round}");

                        if ak != rk && debug_parity {
                            println!(
                                " struct/right key mismatch seed={seed} round={round}\n  struct={ak:x?}\n  right={rk:x?}"
                            );
                        }
                        assert_eq!(ak, rk, "final keys differ vs right seed={seed} round={round}");

                        if av != rv && debug_parity {
                            println!(
                                " struct/right value mismatch seed={seed} round={round}\n  key={ak:x?}\n  struct_val={av:x?}\n  right_val={rv:x?}"
                            );
                        }
                        assert_eq!(av, rv, "final values differ vs right seed={seed} round={round}");
                    }
                    (Some(Err(e)), _, _) | (_, Some(Err(e)), _) | (_, _, Some(Err(e))) => panic!("iteration error: {e:?}"),
                    (a1, b1, r1) => panic!("length mismatch: struct={a1:?} simple={b1:?} right={r1:?} seed={seed} round={round}"),
                }
            }
        }
    }

    #[test]
    #[ignore]
    fn diff_scale_metrics() {
        use rand::rngs::StdRng;
        use rand::{Rng, SeedableRng};

        let _ = env_logger::builder()
            .write_style(WriteStyle::Never)
            .format_timestamp(None)
            .is_test(true)
            .try_init();

        let seed = std::env::var("FIREWOOD_SCALE_SEED").ok().and_then(|s| s.parse().ok()).unwrap_or(0xD155_CA1E_B1A5_u64);
        let total_items = std::env::var("FIREWOOD_SCALE_ITEMS").ok().and_then(|s| s.parse().ok()).unwrap_or(50_000usize);
        let total_modify = std::env::var("FIREWOOD_SCALE_MODIFY").ok().and_then(|s| s.parse().ok()).unwrap_or(total_items / 3);
        eprintln!("diff_scale_metrics: seed={seed} items={total_items} modify={total_modify}");

        let mut rng = StdRng::seed_from_u64(seed);
        let mut base: Vec<(Vec<u8>, Vec<u8>)> = Vec::with_capacity(total_items);
        let mut seen = std::collections::HashSet::new();
        while base.len() < total_items {
            let klen = rng.random_range(1..=32);
            let vlen = rng.random_range(1..=64);
            let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
            if seen.insert(key.clone()) {
                let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
                base.push((key, val));
            }
        }

        let mut left = create_test_merkle();
        let mut right = create_test_merkle();
        for (k, v) in &base {
            left.insert(k, v.clone().into_boxed_slice()).unwrap();
            right.insert(k, v.clone().into_boxed_slice()).unwrap();
        }

        for _ in 0..total_modify {
            let idx = rng.random_range(0..base.len());
            match rng.random_range(0..3) {
                0 => { right.remove(&base[idx].0).ok(); }
                1 => {
                    if right.get_value(&base[idx].0).unwrap().is_some() {
                        let newlen = rng.random_range(1..=64);
                        let newval: Vec<u8> = (0..newlen).map(|_| rng.random()).collect();
                        right.insert(&base[idx].0, newval.into_boxed_slice()).unwrap();
                    }
                }
                _ => {
                    let klen = rng.random_range(1..=32);
                    let vlen = rng.random_range(1..=64);
                    let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
                    let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
                    right.insert(&key, val.into_boxed_slice()).unwrap();
                }
            }
        }

        let left = make_immutable(left);
        let right = make_immutable(right);

        // Run structural diff and export stats/metrics
        let _ops = DiffMerkleNodeStream::new(left.nodestore(), right.nodestore(), Box::new([]))
            .collect::<Result<Vec<_>, _>>()
            .unwrap();

        let snap = super::stats_snapshot();
        let skip_ratio = if snap.pairs_compared == 0 { 0.0 } else { (snap.nodes_skipped_by_hash as f64) / (snap.pairs_compared as f64) };
        eprintln!(
            "SCALE: puts={} deletes={} pairs={} skipped_by_hash={} ({:.1}%) max_stack={} mismatches={}",
            snap.total_ops_put, snap.total_ops_delete, snap.pairs_compared, snap.nodes_skipped_by_hash, skip_ratio * 100.0, snap.max_stack_depth, snap.branch_partial_mismatch
        );
    }
    fn test_diff_empty_mutable_trees() {
        // This is unlikely to happen in practice, but it helps cover the case where
        // hashes do not exist yet.
        let m1 = create_test_merkle();
        let m2 = create_test_merkle();

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));
        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_empty_trees() {
        let m1 = make_immutable(create_test_merkle());
        let m2 = make_immutable(create_test_merkle());

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));
        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_identical_trees() {
        let items = [
            (b"key1".as_slice(), b"value1".as_slice()),
            (b"key2".as_slice(), b"value2".as_slice()),
            (b"key3".as_slice(), b"value3".as_slice()),
        ];

        let m1 = populate_merkle(create_test_merkle(), &items);
        let m2 = populate_merkle(create_test_merkle(), &items);

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));
        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_additions_only() {
        let items = [
            (b"key1".as_slice(), b"value1".as_slice()),
            (b"key2".as_slice(), b"value2".as_slice()),
        ];

        let m1 = make_immutable(create_test_merkle());
        let m2 = populate_merkle(create_test_merkle(), &items);

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(
            op1,
            BatchOp::Put { key, value } if key == Box::from(b"key1".as_slice()) && value.as_ref() == b"value1"
        ));

        let op2 = diff_iter.next().unwrap().unwrap();
        println!("DEBUG additions_only op2: {:?}", op2);
        assert!(matches!(
            op2,
            BatchOp::Put { key, value } if key == Box::from(b"key2".as_slice()) && value.as_ref() == b"value2"
        ));

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_deletions_only() {
        let items = [
            (b"key1".as_slice(), b"value1".as_slice()),
            (b"key2".as_slice(), b"value2".as_slice()),
        ];

        let m1 = populate_merkle(create_test_merkle(), &items);
        let m2 = make_immutable(create_test_merkle());

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op1, BatchOp::Delete { key } if key == Box::from(b"key1".as_slice())));

        let op2 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op2, BatchOp::Delete { key } if key == Box::from(b"key2".as_slice())));

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_modifications() {
        let m1 = populate_merkle(create_test_merkle(), &[(b"key1", b"old_value")]);
        let m2 = populate_merkle(create_test_merkle(), &[(b"key1", b"new_value")]);

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op = diff_iter.next().unwrap().unwrap();
        assert!(matches!(
            op,
            BatchOp::Put { key, value } if key == Box::from(b"key1".as_slice()) && value.as_ref() == b"new_value"
        ));

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_mixed_operations() {
        // m1 has: key1=value1, key2=old_value, key3=value3
        // m2 has: key2=new_value, key4=value4
        // Expected: Delete key1, Put key2=new_value, Delete key3, Put key4=value4

        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"key1", b"value1"),
                (b"key2", b"old_value"),
                (b"key3", b"value3"),
            ],
        );

        let m2 = populate_merkle(
            create_test_merkle(),
            &[(b"key2", b"new_value"), (b"key4", b"value4")],
        );

        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op1, BatchOp::Delete { key } if key == Box::from(b"key1".as_slice())));

        let op2 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(
            op2,
            BatchOp::Put { key, value } if key == Box::from(b"key2".as_slice()) && value.as_ref() == b"new_value"
        ));

        let op3 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(op3, BatchOp::Delete { key } if key == Box::from(b"key3".as_slice())));

        let op4 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(
            op4,
            BatchOp::Put { key, value } if key == Box::from(b"key4".as_slice()) && value.as_ref() == b"value4"
        ));

        assert!(diff_iter.next().is_none());
    }

    #[test]
    fn test_diff_with_start_key() {
        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"aaa", b"value1"),
                (b"bbb", b"value2"),
                (b"ccc", b"value3"),
            ],
        );

        let m2 = populate_merkle(
            create_test_merkle(),
            &[
                (b"aaa", b"value1"),   // Same
                (b"bbb", b"modified"), // Modified
                (b"ddd", b"value4"),   // Added
            ],
        );

        // Start from key "bbb" - should skip "aaa"
        let mut diff_iter = diff_merkle_iterator(&m1, &m2, Box::from(b"bbb".as_slice()));

        let op1 = diff_iter.next().unwrap().unwrap();
        assert!(
            matches!(op1, BatchOp::Put { ref key, ref value } if **key == *b"bbb" && **value == *b"modified"),
            "Expected first operation to be Put bbb=modified, got: {op1:?}",
        );

        let op2 = diff_iter.next().unwrap().unwrap();
        println!("DEBUG with_start_key op2: {:?}", op2);
        assert!(matches!(op2, BatchOp::Delete { key } if key == Box::from(b"ccc".as_slice())));

        let op3 = diff_iter.next().unwrap().unwrap();
        assert!(matches!(
            op3,
            BatchOp::Put { key, value } if key == Box::from(b"ddd".as_slice()) && value.as_ref() == b"value4"
        ));

        assert!(diff_iter.next().is_none());
    }

    #[test]
    #[allow(clippy::indexing_slicing)]
    fn test_diff_interleaved_keys() {
        // m1: a, c, e
        // m2: b, c, d, f
        // Expected: Delete a, Put b, Put d, Delete e, Put f

        let m1 = populate_merkle(
            create_test_merkle(),
            &[(b"a", b"value_a"), (b"c", b"value_c"), (b"e", b"value_e")],
        );

        let m2 = populate_merkle(
            create_test_merkle(),
            &[
                (b"b", b"value_b"),
                (b"c", b"value_c"),
                (b"d", b"value_d"),
                (b"f", b"value_f"),
            ],
        );

        let diff_iter = diff_merkle_iterator(&m1, &m2, Box::new([]));

        let ops: Vec<_> = diff_iter.collect::<Result<Vec<_>, _>>().unwrap();

        assert_eq!(ops.len(), 5);
        assert!(matches!(ops[0], BatchOp::Delete { ref key } if **key == *b"a"));
        assert!(
            matches!(ops[1], BatchOp::Put { ref key, ref value } if **key == *b"b" && **value == *b"value_b")
        );
        assert!(
            matches!(ops[2], BatchOp::Put { ref key, ref value } if **key == *b"d" && **value == *b"value_d")
        );
        assert!(matches!(ops[3], BatchOp::Delete { ref key } if **key == *b"e"));
        assert!(
            matches!(ops[4], BatchOp::Put { ref key, ref value } if **key == *b"f" && **value == *b"value_f")
        );
        // Note: "c" should be skipped as it's identical in both trees
    }

    // example of running this test with a specific seed and maximum tracing in diff code:
    // FIREWOOD_TEST_SEED=14805530293320947613 RUST_LOG=firewood::diff=trace \
    //  cargo test --features logger diff::tests::diff_random_with_deletions
    #[test_case(false, false, 500)]
    #[test_case(false, true, 500)]
    #[test_case(true, false, 500)]
    #[test_case(true, true, 500)]
    #[allow(clippy::indexing_slicing, clippy::cast_precision_loss)]
    fn diff_random_with_deletions(trie1_mutable: bool, trie2_mutable: bool, num_items: usize) {
        use rand::rngs::StdRng;
        use rand::{Rng, SeedableRng};

        let _ = env_logger::builder()
            .write_style(WriteStyle::Never)
            .format_timestamp(None)
            .is_test(true)
            .try_init();

        // Read FIREWOOD_TEST_SEED from environment or use random seed
        let seed = std::env::var("FIREWOOD_TEST_SEED")
            .ok()
            .map_or_else(
                || None,
                |s| Some(str::parse(&s).expect("couldn't parse FIREWOOD_TEST_SEED; must be a u64")),
            )
            .unwrap_or(14805530293320947613);
        //.unwrap_or_else(|| rng().random());

        eprintln!("Seed {seed}: to rerun with this data, export FIREWOOD_TEST_SEED={seed}");
        let mut rng = StdRng::seed_from_u64(seed);

        // Generate random key-value pairs, ensuring uniqueness
        let mut items: Vec<(Vec<u8>, Vec<u8>)> = Vec::new();
        let mut seen_keys = std::collections::HashSet::new();

        while items.len() < num_items {
            let key_len = rng.random_range(1..=32);
            let value_len = rng.random_range(1..=64);

            let key: Vec<u8> = (0..key_len).map(|_| rng.random()).collect();

            // Only add if key is unique
            if seen_keys.insert(key.clone()) {
                let value: Vec<u8> = (0..value_len).map(|_| rng.random()).collect();
                items.push((key, value));
            }
        }

        // Create two identical merkles
        let mut m1 = create_test_merkle();
        let mut m2 = create_test_merkle();

        for (key, value) in &items {
            m1.insert(key, value.clone().into_boxed_slice()).unwrap();
            m2.insert(key, value.clone().into_boxed_slice()).unwrap();
        }

        // Pick two different random indices to delete
        let delete_idx1 = rng.random_range(0..items.len());
        let mut delete_idx2 = rng.random_range(0..items.len());
        while delete_idx2 == delete_idx1 {
            delete_idx2 = rng.random_range(0..items.len());
        }

        let deleted_key1 = &items[delete_idx1].0;
        let deleted_key2 = &items[delete_idx2].0;

        // Get the actual values from the trees before deletion (handles duplicate keys correctly)
        let _actual_value1 = m1.get_value(deleted_key1).unwrap().unwrap();
        let _actual_value2 = m2.get_value(deleted_key2).unwrap().unwrap();

        // Delete different keys from each merkle
        m1.remove(deleted_key1).unwrap();
        println!("expected put for key {deleted_key1:x?}");
        //m2.remove(deleted_key2).unwrap();
        //println!("expected delete for key {:x?}", deleted_key2);

        // Convert to the appropriate type based on test parameters
        let ops: Vec<BatchOp<Box<[u8]>, Box<[u8]>>> = if trie1_mutable && trie2_mutable {
            // Both mutable
            diff_merkle_iterator(&m1, &m2, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        } else if trie1_mutable && !trie2_mutable {
            // m1 mutable, m2 immutable
            let m2_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m2.try_into().unwrap();
            diff_merkle_iterator(&m1, &m2_immut, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        } else if !trie1_mutable && trie2_mutable {
            // m1 immutable, m2 mutable
            let m1_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m1.try_into().unwrap();
            diff_merkle_iterator(&m1_immut, &m2, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        } else {
            // Both immutable
            let m1_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m1.try_into().unwrap();
            let m2_immut: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
                m2.try_into().unwrap();
            println!("---m1\n{}", m1_immut.dump_to_string().unwrap());
            println!("---m2\n{}", m2_immut.dump_to_string().unwrap());
            diff_merkle_iterator(&m1_immut, &m2_immut, Box::new([]))
                .collect::<Result<Vec<_>, _>>()
                .unwrap()
        };

        // Should have exactly 2 operations: 1 delete + 1 put
        if ops.len() != 2 {
            println!(
                "DEBUG: Expected 2 operations but got {} for seed {}",
                ops.len(),
                seed
            );
            for (i, op) in ops.iter().enumerate() {
                match op {
                    BatchOp::Delete { key } => {
                        println!("  {}: Delete key: {:x?}", i, key.as_ref());
                    }
                    BatchOp::Put { key, value: _ } => {
                        println!("  {}: Put key: {:x?}", i, key.as_ref());
                    }
                    BatchOp::DeleteRange { .. } => {
                        println!("  {i}: DeleteRange");
                    }
                }
            }
        }
        assert_eq!(ops.len(), 2);
    }

    #[test]
    #[allow(clippy::pedantic)]
    fn test_hash_optimization_reduces_node_reads() {
        // This test focuses specifically on validating that hash optimization reduces node reads
        // by comparing baseline full-traversal reads vs optimized diff operation reads.
        // Diff correctness is validated by other tests.
        use metrics::{Key, Label, Recorder};
        use metrics_util::registry::{AtomicStorage, Registry};
        use std::sync::Arc;
        use std::sync::atomic::Ordering;

        /// Test metrics recorder that captures counter values for testing
        #[derive(derive_more::Debug, Clone)]
        struct TestRecorder {
            registry: Arc<Registry<Key, AtomicStorage>>,
        }

        impl TestRecorder {
            fn new() -> Self {
                Self {
                    registry: Arc::new(Registry::atomic()),
                }
            }

            fn get_counter_value(
                &self,
                key_name: &'static str,
                labels: &[(&'static str, &'static str)],
            ) -> u64 {
                let key = if labels.is_empty() {
                    Key::from_name(key_name)
                } else {
                    let label_vec: Vec<Label> =
                        labels.iter().map(|(k, v)| Label::new(*k, *v)).collect();
                    Key::from_name(key_name).with_extra_labels(label_vec)
                };

                self.registry
                    .get_counter_handles()
                    .into_iter()
                    .find(|(k, _)| k == &key)
                    .map_or(0, |(_, counter)| counter.load(Ordering::Relaxed))
            }
        }

        impl Recorder for TestRecorder {
            fn describe_counter(
                &self,
                _key: metrics::KeyName,
                _unit: Option<metrics::Unit>,
                _description: metrics::SharedString,
            ) {
            }
            fn describe_gauge(
                &self,
                _key: metrics::KeyName,
                _unit: Option<metrics::Unit>,
                _description: metrics::SharedString,
            ) {
            }
            fn describe_histogram(
                &self,
                _key: metrics::KeyName,
                _unit: Option<metrics::Unit>,
                _description: metrics::SharedString,
            ) {
            }

            fn register_counter(
                &self,
                key: &Key,
                _metadata: &metrics::Metadata<'_>,
            ) -> metrics::Counter {
                self.registry
                    .get_or_create_counter(key, |c| c.clone().into())
            }

            fn register_gauge(
                &self,
                key: &Key,
                _metadata: &metrics::Metadata<'_>,
            ) -> metrics::Gauge {
                self.registry.get_or_create_gauge(key, |c| c.clone().into())
            }

            fn register_histogram(
                &self,
                key: &Key,
                _metadata: &metrics::Metadata<'_>,
            ) -> metrics::Histogram {
                self.registry
                    .get_or_create_histogram(key, |c| c.clone().into())
            }
        }

        // Set up test recorder - if it fails, skip the entire test
        let recorder = TestRecorder::new();
        if metrics::set_global_recorder(recorder.clone()).is_err() {
            println!("  Could not set test recorder (already set) - skipping test");
            return;
        }

        // Create test data with substantial shared content and unique content
        let tree1_items = [
            // Large shared content that will form identical subtrees
            (
                b"shared/branch_a/deep/file1".as_slice(),
                b"shared_value1".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file2".as_slice(),
                b"shared_value2".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file3".as_slice(),
                b"shared_value3".as_slice(),
            ),
            (b"shared/branch_b/file1".as_slice(), b"shared_b1".as_slice()),
            (b"shared/branch_b/file2".as_slice(), b"shared_b2".as_slice()),
            (
                b"shared/branch_c/deep/nested/file".as_slice(),
                b"shared_nested".as_slice(),
            ),
            (b"shared/common".as_slice(), b"common_value".as_slice()),
            // Unique to tree1
            (b"tree1_unique/x".as_slice(), b"x_value".as_slice()),
            (b"tree1_unique/y".as_slice(), b"y_value".as_slice()),
            (b"tree1_unique/z".as_slice(), b"z_value".as_slice()),
        ];

        let tree2_items = [
            // Identical shared content
            (
                b"shared/branch_a/deep/file1".as_slice(),
                b"shared_value1".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file2".as_slice(),
                b"shared_value2".as_slice(),
            ),
            (
                b"shared/branch_a/deep/file3".as_slice(),
                b"shared_value3".as_slice(),
            ),
            (b"shared/branch_b/file1".as_slice(), b"shared_b1".as_slice()),
            (b"shared/branch_b/file2".as_slice(), b"shared_b2".as_slice()),
            (
                b"shared/branch_c/deep/nested/file".as_slice(),
                b"shared_nested".as_slice(),
            ),
            (b"shared/common".as_slice(), b"common_value".as_slice()),
            // Unique to tree2
            (b"tree2_unique/p".as_slice(), b"p_value".as_slice()),
            (b"tree2_unique/q".as_slice(), b"q_value".as_slice()),
            (b"tree2_unique/r".as_slice(), b"r_value".as_slice()),
        ];

        // Create immutable trees (required for hash-based optimization)
        let m1 = populate_merkle(create_test_merkle(), &tree1_items);
        let m2 = populate_merkle(create_test_merkle(), &tree2_items);

        // BASELINE: Measure total reads from complete tree traversals
        let baseline_reads_before =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);

        // Traverse tree1 completely
        let tree1_iter = m1.key_value_iter();
        let tree1_count = tree1_iter.count();

        // Traverse tree2 completely
        let tree2_iter = m2.key_value_iter();
        let tree2_count = tree2_iter.count();

        let baseline_reads_after =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);
        let baseline_reads = baseline_reads_after - baseline_reads_before;

        println!("Baseline - Tree1 items: {tree1_count}, Tree2 items: {tree2_count}");
        println!("Baseline total reads (both trees fully traversed): {baseline_reads}");

        // DIFF TEST: Measure reads from hash-optimized diff operation
        let diff_reads_before =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);

        let diff_stream =
            DiffMerkleKeyValueStreams::new(m1.nodestore(), m2.nodestore(), Box::new([]));
        let diff_results_count = diff_stream.count();

        let diff_reads_after =
            recorder.get_counter_value("firewood.read_node", &[("from", "proposal")]);
        let diff_reads = diff_reads_after - diff_reads_before;

        println!("Diff operation reads: {diff_reads}");
        println!("Diff results count: {diff_results_count}");

        // Both should have some reads since we're using immutable proposals
        assert!(
            baseline_reads > 0,
            "Expected baseline reads from tree traversals"
        );
        assert!(diff_reads > 0, "Expected reads from diff operation");

        // Verify hash optimization is working - should read FEWER nodes than full traversal
        assert!(
            diff_reads < baseline_reads,
            "Hash optimization failed: diff reads ({diff_reads}) should be less than baseline ({baseline_reads}) for trees with shared content"
        );

        println!(" Node read optimization verified: {diff_reads} vs {baseline_reads} reads");

        // Verify we found some diff operations (exact count and content validated by other tests)
        assert!(
            diff_results_count > 0,
            "Expected to find diff operations for trees with different content"
        );

        println!("   - Baseline reads: {baseline_reads}");
        println!(
            "   - Diff reads: {} ({:.1}% of baseline)",
            diff_reads,
            (diff_reads as f64 / baseline_reads as f64) * 100.0
        );
        println!(
            "   - Node read reduction: {} ({:.1}%)",
            baseline_reads - diff_reads,
            ((baseline_reads - diff_reads) as f64 / baseline_reads as f64) * 100.0
        );
        println!("   - Diff operations found: {diff_results_count}");
    }

    #[test]
    #[ignore]
    fn diff_large_random_stress() {
        use rand::rngs::StdRng;
        use rand::{Rng, SeedableRng};

        let _ = env_logger::builder()
            .write_style(WriteStyle::Never)
            .format_timestamp(None)
            .is_test(true)
            .try_init();

        // Default parameters (can be overridden by env vars)
        let default_items = 5000usize;
        let default_modify = 1000usize; // modifies or inserts
        let seed = std::env::var("FIREWOOD_STRESS_SEED")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(0xD1FF_C0DE_BAAD_F00D);
        let total_items = std::env::var("FIREWOOD_STRESS_ITEMS")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(default_items);
        let total_modify = std::env::var("FIREWOOD_STRESS_MODIFY")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(default_modify);

        eprintln!(
            "diff_large_random_stress: seed={seed} items={total_items} modify={total_modify}"
        );
        let mut rng = StdRng::seed_from_u64(seed);

        // Build base unique keys and values
        let mut base: Vec<(Vec<u8>, Vec<u8>)> = Vec::with_capacity(total_items);
        let mut seen = std::collections::HashSet::new();
        while base.len() < total_items {
            let klen: usize = rng.random_range(1..=32);
            let vlen: usize = rng.random_range(1..=64);
            let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
            if !seen.insert(key.clone()) {
                continue;
            }
            let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
            base.push((key, val));
        }

        // Left and right start identical
        let mut left = create_test_merkle();
        let mut right = create_test_merkle();
        for (k, v) in &base {
            left.insert(k, v.clone().into_boxed_slice()).unwrap();
            right.insert(k, v.clone().into_boxed_slice()).unwrap();
        }

        // Make modifications on the right: mix of deletes, updates, and inserts
        for _ in 0..total_modify {
            match rng.random_range(0..100) {
                0..=24 => {
                    // delete 25%
                    let idx = rng.random_range(0..base.len());
                    right.remove(&base[idx].0).ok();
                }
                25..=74 => {
                    // update 50%
                    let idx = rng.random_range(0..base.len());
                    let newlen = rng.random_range(1..=64);
                    let newval: Vec<u8> = (0..newlen).map(|_| rng.random()).collect();
                    right
                        .insert(&base[idx].0, newval.into_boxed_slice())
                        .unwrap();
                }
                _ => {
                    // insert 25%
                    let klen = rng.random_range(1..=32);
                    let vlen = rng.random_range(1..=64);
                    let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
                    let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
                    right.insert(&key, val.into_boxed_slice()).unwrap();
                }
            }
        }

        // Freeze to immutable for diff
        let left = make_immutable(left);
        let right = make_immutable(right);

        // Compute diff ops using the structural path (now dual key-stream merge under the hood)
        let ops = diff_merkle_iterator(&left, &right, Box::new([]))
            .collect::<Result<Vec<_>, _>>()
            .unwrap();

        // Apply ops to left.fork()
        let mut fork = left.fork().unwrap();
        for op in &ops {
            match op {
                BatchOp::Put { key, value } => {
                    fork.insert(key, value.clone()).unwrap();
                }
                BatchOp::Delete { key } => {
                    fork.remove(key).unwrap();
                }
                BatchOp::DeleteRange { prefix } => {
                    fork.remove_prefix(prefix).unwrap();
                }
            }
        }
        let left_after: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
            fork.try_into().unwrap();

        // Verify left_after == right by comparing full key/value iteration
        let mut l = crate::iter::MerkleKeyValueIter::from(left_after.nodestore());
        let mut r = crate::iter::MerkleKeyValueIter::from(right.nodestore());
        loop {
            match (l.next(), r.next()) {
                (None, None) => break,
                (Some(Ok((lk, lv))), Some(Ok((rk, rv)))) => {
                    assert_eq!(lk, rk, "keys differ");
                    assert_eq!(lv, rv, "values differ for key {:?}", lk);
                }
                (Some(Err(e)), _) | (_, Some(Err(e))) => panic!("iteration error: {e:?}"),
                (ln, rn) => panic!("length mismatch: left={ln:?} right={rn:?}"),
            }
        }
    }

    #[test]
    #[ignore]
    fn debug_stress_small() {
        use rand::rngs::StdRng;
        use rand::{Rng, SeedableRng};

        let _ = env_logger::builder()
            .write_style(WriteStyle::Never)
            .format_timestamp(None)
            .is_test(true)
            .try_init();

        let seed = 0xD1FF_C0DE_BAAD_F00D_u64;
        let total_items = 20usize;
        let total_modify = 10usize;
        eprintln!(
            "debug_stress_small: seed={seed} items={total_items} modify={total_modify}"
        );
        let mut rng = StdRng::seed_from_u64(seed);

        // Build base unique keys and values
        let mut base: Vec<(Vec<u8>, Vec<u8>)> = Vec::with_capacity(total_items);
        let mut seen = std::collections::HashSet::new();
        while base.len() < total_items {
            let klen = rng.random_range(1..=32);
            let vlen = rng.random_range(1..=64);
            let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
            if seen.insert(key.clone()) {
                let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
                base.push((key, val));
            }
        }

        let mut left = create_test_merkle();
        let mut right = create_test_merkle();
        for (k, v) in &base {
            left.insert(k, v.clone().into_boxed_slice()).unwrap();
            right.insert(k, v.clone().into_boxed_slice()).unwrap();
        }
        // Modify right
        for _ in 0..total_modify {
            let idx = rng.random_range(0..base.len());
            match rng.random_range(0..3) {
                0 => {
                    // delete
                    right.remove(&base[idx].0).ok();
                }
                1 => {
                    // update existing
                    if right.get_value(&base[idx].0).unwrap().is_some() {
                        let newlen = rng.random_range(1..=64);
                        let newval: Vec<u8> = (0..newlen).map(|_| rng.random()).collect();
                        right
                            .insert(&base[idx].0, newval.into_boxed_slice())
                            .unwrap();
                    }
                }
                _ => {
                    // insert
                    let klen = rng.random_range(1..=32);
                    let vlen = rng.random_range(1..=64);
                    let key: Vec<u8> = (0..klen).map(|_| rng.random()).collect();
                    let val: Vec<u8> = (0..vlen).map(|_| rng.random()).collect();
                    right.insert(&key, val.into_boxed_slice()).unwrap();
                }
            }
        }

        // Freeze to immutable for diff
        let left = make_immutable(left);
        let right = make_immutable(right);

        // Compute ops
        let ops = diff_merkle_iterator(&left, &right, Box::new([]))
            .collect::<Result<Vec<_>, _>>()
            .unwrap();
        eprintln!("ops count={}", ops.len());

        // Apply and compare keys
        let mut fork = left.fork().unwrap();
        for op in &ops {
            match op {
                BatchOp::Put { key, value } => {
                    fork.insert(key, value.clone()).unwrap();
                }
                BatchOp::Delete { key } => {
                    fork.remove(key).unwrap();
                }
                BatchOp::DeleteRange { prefix } => {
                    fork.remove_prefix(prefix).unwrap();
                }
            }
        }
        let left_after: Merkle<NodeStore<Arc<ImmutableProposal>, MemStore>> =
            fork.try_into().unwrap();

        let mut l = crate::iter::MerkleKeyValueIter::from(left_after.nodestore());
        let mut r = crate::iter::MerkleKeyValueIter::from(right.nodestore());
        let mut left_keys = Vec::new();
        let mut right_keys = Vec::new();
        while let Some(n) = l.next() {
            let (k, _v) = n.unwrap();
            left_keys.push(k);
        }
        while let Some(n) = r.next() {
            let (k, _v) = n.unwrap();
            right_keys.push(k);
        }
        eprintln!("left_after keys = {:?}", left_keys);
        eprintln!("right keys      = {:?}", right_keys);
        let left_only: Vec<_> = left_keys
            .iter()
            .filter(|k| !right_keys.contains(k))
            .collect();
        let right_only: Vec<_> = right_keys
            .iter()
            .filter(|k| !left_keys.contains(k))
            .collect();
        eprintln!("left_only = {:?}", left_only);
        eprintln!("right_only = {:?}", right_only);
        assert!(left_only.is_empty() && right_only.is_empty());
    }

    #[test]
    fn test_diff_processes_all_branch_children() {
        // This test verifies the bug fix: ensure that after finding different children
        // at the same position in a branch, the algorithm continues to process remaining children
        let m1 = create_test_merkle();
        let m1 = populate_merkle(
            m1,
            &[
                (b"branch_a/file", b"shared_value"),    // This will be identical
                (b"branch_b/file", b"value1"),          // This will be changed
                (b"branch_c/file", b"left_only_value"), // This will be deleted
            ],
        );

        let m2 = create_test_merkle();
        let m2 = populate_merkle(
            m2,
            &[
                (b"branch_a/file", b"shared_value"),     // Identical to tree1
                (b"branch_b/file", b"value1_modified"),  // Different value
                (b"branch_d/file", b"right_only_value"), // This will be added
            ],
        );

        let diff_stream =
            DiffMerkleKeyValueStreams::new(m1.nodestore(), m2.nodestore(), Key::default());

        let results: Vec<_> = diff_stream.collect::<Result<Vec<_>, _>>().unwrap();

        // Should find all differences:
        // 1. branch_b/file modified
        // 2. branch_c/file deleted
        // 3. branch_d/file added
        assert_eq!(results.len(), 3, "Should find all 3 differences");

        // Verify specific operations
        let mut changes = 0;
        let mut deletions = 0;
        let mut additions = 0;

        for result in &results {
            match result {
                BatchOp::Put { key, value: _ } => {
                    if key.as_ref() == b"branch_b/file" {
                        changes += 1;
                        assert_eq!(&**key, b"branch_b/file");
                    } else if key.as_ref() == b"branch_d/file" {
                        additions += 1;
                        assert_eq!(&**key, b"branch_d/file");
                    }
                }
                BatchOp::Delete { key } => {
                    deletions += 1;
                    assert_eq!(&**key, b"branch_c/file");
                }
                BatchOp::DeleteRange { .. } => {
                    panic!("DeleteRange not expected in this test");
                }
            }
        }

        assert_eq!(changes, 1, "Should have 1 change");
        assert_eq!(deletions, 1, "Should have 1 deletion");
        assert_eq!(additions, 1, "Should have 1 addition");
    }

    #[test]
    fn test_all_six_diff_states_coverage() {
        // This test ensures comprehensive coverage of all 6 diff iteration states
        // by creating specific scenarios that guarantee each state is exercised

        // Create trees with carefully designed structure to trigger all states:
        // 1. Deep branching structure to ensure branch nodes exist
        // 2. Mix of shared, modified, left-only, and right-only content
        // 3. Different tree shapes to force visited states

        let tree1_data = vec![
            // Shared deep structure (will trigger VisitedNodePairState)
            (b"shared/deep/branch/file1".as_slice(), b"value1".as_slice()),
            (b"shared/deep/branch/file2".as_slice(), b"value2".as_slice()),
            (b"shared/deep/branch/file3".as_slice(), b"value3".as_slice()),
            // Modified values (will trigger UnvisitedNodePairState)
            (b"modified/path/file".as_slice(), b"old_value".as_slice()),
            // Left-only deep structure (will trigger VisitedNodeLeftState)
            (
                b"left_only/deep/branch/file1".as_slice(),
                b"left_val1".as_slice(),
            ),
            (
                b"left_only/deep/branch/file2".as_slice(),
                b"left_val2".as_slice(),
            ),
            (
                b"left_only/deep/branch/file3".as_slice(),
                b"left_val3".as_slice(),
            ),
            // Simple left-only (will trigger UnvisitedNodeLeftState)
            (
                b"simple_left_only".as_slice(),
                b"simple_left_value".as_slice(),
            ),
            // Mixed branch with some shared children
            (
                b"mixed_branch/shared_child".as_slice(),
                b"shared".as_slice(),
            ),
            (
                b"mixed_branch/left_child".as_slice(),
                b"left_value".as_slice(),
            ),
        ];

        let tree2_data = vec![
            // Same shared deep structure
            (b"shared/deep/branch/file1".as_slice(), b"value1".as_slice()),
            (b"shared/deep/branch/file2".as_slice(), b"value2".as_slice()),
            (b"shared/deep/branch/file3".as_slice(), b"value3".as_slice()),
            // Modified values
            (b"modified/path/file".as_slice(), b"new_value".as_slice()),
            // Right-only deep structure (will trigger VisitedNodeRightState)
            (
                b"right_only/deep/branch/file1".as_slice(),
                b"right_val1".as_slice(),
            ),
            (
                b"right_only/deep/branch/file2".as_slice(),
                b"right_val2".as_slice(),
            ),
            (
                b"right_only/deep/branch/file3".as_slice(),
                b"right_val3".as_slice(),
            ),
            // Simple right-only (will trigger UnvisitedNodeRightState)
            (
                b"simple_right_only".as_slice(),
                b"simple_right_value".as_slice(),
            ),
            // Mixed branch with some shared children
            (
                b"mixed_branch/shared_child".as_slice(),
                b"shared".as_slice(),
            ),
            (
                b"mixed_branch/right_child".as_slice(),
                b"right_value".as_slice(),
            ),
        ];

        let m1 = populate_merkle(create_test_merkle(), &tree1_data);
        let m2 = populate_merkle(create_test_merkle(), &tree2_data);

        let diff_iter = diff_merkle_iterator(&m1, &m2, Key::default());
        let results: Vec<_> = diff_iter.collect::<Result<Vec<_>, _>>().unwrap();

        // Verify we found the expected differences
        let mut deletions = 0;
        let mut additions = 0;

        for result in &results {
            match result {
                BatchOp::Put { .. } => additions += 1,
                BatchOp::Delete { .. } => deletions += 1,
                BatchOp::DeleteRange { .. } => {
                    panic!("DeleteRange not expected in this test");
                }
            }
        }

        // Expected differences using BatchOp representation:
        // - Both modifications and additions are represented as Put operations
        // - Deletions are Delete operations
        // - We expect multiple operations for the different scenarios
        assert!(deletions >= 4, "Expected at least 4 deletions");
        assert!(
            additions >= 4,
            "Expected at least 4 additions (includes modifications)"
        );

        println!(" All 6 diff states coverage test passed:");
        println!("   - Deletions: {deletions}");
        println!("   - Additions (includes modifications): {additions}");
        println!("   - This test exercises scenarios that should trigger:");
        println!("     1. UnvisitedNodePairState (comparing modified nodes)");
        println!("     2. UnvisitedNodeLeftState (simple left-only nodes)");
        println!("     3. UnvisitedNodeRightState (simple right-only nodes)");
        println!("     4. VisitedNodePairState (shared branch with different children)");
        println!("     5. VisitedNodeLeftState (left-only branch structures)");
        println!("     6. VisitedNodeRightState (right-only branch structures)");
    }

    #[test]
    fn test_branch_vs_leaf_state_transitions() {
        // This test specifically covers the branch-vs-leaf scenarios in UnvisitedNodePairState
        // which can trigger different state transitions

        // Tree1: Has a branch structure at "path"
        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"path/file1".as_slice(), b"value1".as_slice()),
                (b"path/file2".as_slice(), b"value2".as_slice()),
            ],
        );

        // Tree2: Has a leaf at "path"
        let m2 = populate_merkle(
            create_test_merkle(),
            &[(b"path".as_slice(), b"leaf_value".as_slice())],
        );

        let diff_stream =
            DiffMerkleKeyValueStreams::new(m1.nodestore(), m2.nodestore(), Key::default());

        let results: Vec<_> = diff_stream.collect::<Result<Vec<_>, _>>().unwrap();

        // Should find:
        // - Deletion of path/file1 and path/file2
        // - Addition of path (leaf)
        assert!(
            results.len() >= 2,
            "Should find multiple differences for branch vs leaf"
        );

        println!(
            " Branch vs leaf transitions test passed with {} operations",
            results.len()
        );
    }

    #[test_case(true, false, 0, 1)] // same value, m1->m2: no put needed, delete prefix/b
    #[test_case(false, false, 1, 1)] // diff value, m1->m2: put prefix/a, delete prefix/b
    #[test_case(true, true, 1, 0)] // same value, m2->m1: no change to prefix/a, add prefix/b
    #[test_case(false, true, 2, 0)] // diff value, m2->m1: update prefix/a, add prefix/b
    #[allow(clippy::arithmetic_side_effects)]
    fn test_branch_vs_leaf_empty_partial_path_bug(
        same_value: bool,
        backwards: bool,
        expected_puts: usize,
        expected_deletes: usize,
    ) {
        // This test covers the exclusion logic in Branch vs Leaf scenarios.
        // It creates a case where one tree has a branch with children, and the other
        // tree has a leaf that matches one of those children - testing that the
        // matching child gets excluded from deletion and properly compared instead.
        //
        // Parameters:
        // - same_value: whether prefix/a has the same value in both trees
        // - backwards: whether to compare m2->m1 instead of m1->m2
        // - expected_puts/expected_deletes: expected operation counts

        // Tree1: Create children under "prefix" but no value at "prefix" itself
        // This creates a branch node at "prefix" with value=None
        let m1 = populate_merkle(
            create_test_merkle(),
            &[
                (b"prefix/a".as_slice(), b"value_a".as_slice()),
                (b"prefix/b".as_slice(), b"value_b".as_slice()),
            ],
        );

        // Tree2: Create just a single value at "prefix/a"
        // Value depends on same_value parameter
        let m2_value: &[u8] = if same_value {
            b"value_a"
        } else {
            b"prefix_a_value"
        };
        let m2 = populate_merkle(create_test_merkle(), &[(b"prefix/a".as_slice(), m2_value)]);

        // Choose direction based on backwards parameter
        let (tree_left, tree_right, direction_desc) = if backwards {
            (m2.nodestore(), m1.nodestore(), "m2->m1")
        } else {
            (m1.nodestore(), m2.nodestore(), "m1->m2")
        };

        let diff_stream = DiffMerkleKeyValueStreams::new(tree_left, tree_right, Key::default());
        let results: Vec<_> = diff_stream.collect::<Result<Vec<_>, _>>().unwrap();

        let delete_count = results
            .iter()
            .filter(|op| matches!(op, BatchOp::Delete { .. }))
            .count();

        let put_count = results
            .iter()
            .filter(|op| matches!(op, BatchOp::Put { .. }))
            .count();

        // Verify against expected counts
        assert_eq!(
            put_count, expected_puts,
            "Put count mismatch for {direction_desc} (same_value={same_value}, backwards={backwards}), results={results:x?}"
        );
        assert_eq!(
            delete_count, expected_deletes,
            "Delete count mismatch for {direction_desc} (same_value={same_value}, backwards={backwards}), results={results:x?}"
        );
        assert_eq!(
            results.len(),
            expected_puts + expected_deletes,
            "Total operation count mismatch for {direction_desc} (same_value={same_value}, backwards={backwards}), results={results:x?}"
        );

        println!(
            " Branch vs leaf test passed: {direction_desc} (same_value={same_value}, backwards={backwards}) - {put_count} puts, {delete_count} deletes"
        );
    }
}
