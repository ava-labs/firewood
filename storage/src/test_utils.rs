// Copyright (C) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE.md for licensing terms.

use std::cell::RefCell;
use std::rc::Rc;

#[expect(
    clippy::disallowed_types,
    reason = "we are implementing the alternative"
)]
use rand::rngs::StdRng;
#[expect(
    clippy::disallowed_types,
    reason = "we are implementing the alternative"
)]
use rand::{RngCore, SeedableRng, TryRngCore};

#[derive(Debug, Clone)]
#[must_use]
/// A seeded random number generator for testing purposes.
#[expect(
    clippy::disallowed_types,
    reason = "we are implementing the alternative"
)]
pub struct SeededRng(Rc<RefCell<StdRng>>);

const ENV: &str = "FIREWOOD_TEST_SEED";
// `concat!` does not work with constants, only literals and certain special expressions,
const EXPECT: &str = "FIREWOOD_TEST_SEED, when present, must contain a valid u64 value";

impl SeededRng {
    /// Creates a new `SeededRng` with the given seed.
    pub fn new(seed: u64) -> Self {
        #![expect(
            clippy::disallowed_types,
            reason = "we are implementing the alternative"
        )]
        // we do not log here so that we don't log if `from_option` was used with
        // a `Some` value (the seed did not come from the environment)
        Self(Rc::new(RefCell::new(StdRng::seed_from_u64(seed))))
    }

    /// Creates a new `SeededRng` from an `Option<u64>`.
    ///
    /// If the provided value is `None`, [`SeededRng::from_env_or_random`] will
    /// be used to check the environment variable or otherwise generate a random seed.
    pub fn from_option(seed: Option<u64>) -> Self {
        seed.map_or_else(Self::from_env_or_random, Self::new)
    }

    /// Creates a new `SeededRng` from an environment variable set seed.
    ///
    /// # Returns
    ///
    /// None if the environment variable is not set, otherwise a [`SeededRng`]
    /// with the seed initialized.
    ///
    /// # Panics
    ///
    /// Panics if the environment variable is present but is not a valid `u64`.
    #[track_caller]
    #[must_use]
    pub fn from_env() -> Option<Self> {
        let seed = std::env::var_os(ENV)?
            .into_string()
            .ok()
            .and_then(|s| s.parse().ok())
            .expect(EXPECT);
        eprintln!("Seed {seed}: to rerun with this data, export {ENV}={seed}");
        Some(Self::new(seed))
    }

    /// Creates a new `SeededRng` with a random seed generated by the OS.
    #[track_caller]
    pub fn from_random() -> Self {
        let seed = rand::rngs::OsRng.unwrap_err().next_u64();
        eprintln!("Seed {seed}: to rerun with this data, export {ENV}={seed}");
        Self::new(seed)
    }

    /// Creates a new `SeededRng` from an environment variable (if set), otherwise
    /// a random seed.
    #[track_caller]
    pub fn from_env_or_random() -> Self {
        Self::from_env().unwrap_or_else(Self::from_random)
    }

    /// Creates a new `SeededRng` seeded by this Rng.
    pub fn seeded_fork(&self) -> Self {
        Self::new(self.next_u64())
    }

    /// Convenience method to generate a new u32 from the Rng with a reference
    /// and not a mutable reference.
    #[must_use]
    pub fn next_u32(&self) -> u32 {
        self.0.borrow_mut().next_u32()
    }

    /// Convenience method to generate a new u64 from the Rng with a reference
    /// and not a mutable reference.
    #[must_use]
    pub fn next_u64(&self) -> u64 {
        self.0.borrow_mut().next_u64()
    }

    /// Convenience method to fill a byte slice with random bytes from the Rng
    /// with a reference and not a mutable reference.
    pub fn fill_bytes(&self, dst: &mut [u8]) {
        self.0.borrow_mut().fill_bytes(dst);
    }

    /// Convenience method for [`rand::Rng::random`] but with a reference and
    /// instead of a mutable reference.
    #[must_use]
    #[inline]
    pub fn random<T>(&self) -> T
    where
        rand::distr::StandardUniform: rand::distr::Distribution<T>,
    {
        rand::Rng::random(&mut &*self)
    }

    /// Convenience method for [`rand::Rng::random_range`] but with a reference
    /// and instead of a mutable reference.
    #[track_caller]
    pub fn random_range<T, R>(&self, range: R) -> T
    where
        T: rand::distr::uniform::SampleUniform,
        R: rand::distr::uniform::SampleRange<T>,
    {
        rand::Rng::random_range(&mut &*self, range)
    }
}

impl rand::RngCore for SeededRng {
    #[inline]
    fn next_u32(&mut self) -> u32 {
        SeededRng::next_u32(self)
    }

    #[inline]
    fn next_u64(&mut self) -> u64 {
        SeededRng::next_u64(self)
    }

    #[inline]
    fn fill_bytes(&mut self, dst: &mut [u8]) {
        SeededRng::fill_bytes(self, dst);
    }
}

impl rand::RngCore for &SeededRng {
    #[inline]
    fn next_u32(&mut self) -> u32 {
        SeededRng::next_u32(self)
    }

    #[inline]
    fn next_u64(&mut self) -> u64 {
        SeededRng::next_u64(self)
    }

    #[inline]
    fn fill_bytes(&mut self, dst: &mut [u8]) {
        SeededRng::fill_bytes(self, dst);
    }
}
