// Copyright (C) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE.md for licensing terms.

// This file was @generated by cbindgen. Do not edit this file manually.
// Run `cargo build --target firewood-ffi` to regenerate this file.

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * A handle to the database, returned by `fwd_open_db`.
 *
 * These handles are passed to the other FFI functions.
 *
 */
typedef struct DatabaseHandle DatabaseHandle;

/**
 * An opaque wrapper around an Iterator.
 */
typedef struct IteratorHandle IteratorHandle;

/**
 * An opaque wrapper around a Proposal that also retains a reference to the
 * database handle it was created from.
 */
typedef struct ProposalHandle ProposalHandle;

/**
 * A database hash key, used in FFI functions that require hashes.
 * This type requires no allocation and can be copied freely and
 * dropped without any additional overhead.
 *
 * This is useful because it is the same size as 4 words which is equivalent
 * to 2 heap-allocated slices (pointer + length each), or 1.5 vectors (which
 * uses an extra word for allocation capacity) and it can be passed around
 * without needing to allocate or deallocate memory.
 */
typedef struct HashKey {
  uint8_t _0[32];
} HashKey;

/**
 * A Rust-owned vector of bytes that can be passed to C code.
 *
 * C callers must free this memory using the respective FFI function for the
 * concrete type (but not using the `free` function from the C standard library).
 */
typedef struct OwnedSlice_u8 {
  uint8_t *ptr;
  size_t len;
} OwnedSlice_u8;

/**
 * A type alias for a rust-owned byte slice.
 */
typedef struct OwnedSlice_u8 OwnedBytes;

/**
 * A result type returned from FFI functions return the database root hash. This
 * may or may not be after a mutation.
 */
typedef enum HashResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  HashResult_NullHandlePointer,
  /**
   * The proposal resulted in an empty database or the database currently has
   * no root hash.
   */
  HashResult_None,
  /**
   * The mutation was successful and the root hash is returned, if this result
   * was from a mutation. Otherwise, this is the current root hash of the
   * database.
   */
  HashResult_Some,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  HashResult_Err,
} HashResult_Tag;

typedef struct HashResult {
  HashResult_Tag tag;
  union {
    struct {
      struct HashKey some;
    };
    struct {
      OwnedBytes err;
    };
  };
} HashResult;

/**
 * A borrowed byte slice. Used to represent data that was passed in from C
 * callers and will not be freed or retained by Rust code.
 */
typedef struct BorrowedSlice_u8 {
  /**
   * A pointer to the slice of bytes. This can be null if the slice is empty.
   *
   * If the pointer is not null, it must point to a valid slice of `len`
   * elements sized and aligned for `T`.
   *
   * As a note, [`NonNull`] is not appropriate here because [`NonNull`] pointer
   * provenance requires mutable access to the pointer, which is not an invariant
   * we want to enforce here. We want (and require) the pointer to be immutable.
   *
   * [`NonNull`]: std::ptr::NonNull
   */
  const uint8_t *ptr;
  /**
   * The length of the slice. It is ignored if the pointer is null; however,
   * if the pointer is not null, it must be equal to the number of elements
   * pointed to by `ptr`.
   */
  size_t len;
} BorrowedSlice_u8;

/**
 * A type alias for a borrowed byte slice.
 *
 * C callers can use this to pass in a byte slice that will not be freed by Rust
 * code.
 *
 * C callers must ensure that the pointer, if not null, points to a valid slice
 * of bytes of length `len`. C callers must also ensure that the slice is valid
 * for the duration of the C function call that was passed this slice.
 */
typedef struct BorrowedSlice_u8 BorrowedBytes;

/**
 * A `KeyValue` represents a key-value pair, passed to the FFI.
 */
typedef struct KeyValuePair {
  BorrowedBytes key;
  BorrowedBytes value;
} KeyValuePair;

/**
 * A borrowed byte slice. Used to represent data that was passed in from C
 * callers and will not be freed or retained by Rust code.
 */
typedef struct BorrowedSlice_KeyValuePair {
  /**
   * A pointer to the slice of bytes. This can be null if the slice is empty.
   *
   * If the pointer is not null, it must point to a valid slice of `len`
   * elements sized and aligned for `T`.
   *
   * As a note, [`NonNull`] is not appropriate here because [`NonNull`] pointer
   * provenance requires mutable access to the pointer, which is not an invariant
   * we want to enforce here. We want (and require) the pointer to be immutable.
   *
   * [`NonNull`]: std::ptr::NonNull
   */
  const struct KeyValuePair *ptr;
  /**
   * The length of the slice. It is ignored if the pointer is null; however,
   * if the pointer is not null, it must be equal to the number of elements
   * pointed to by `ptr`.
   */
  size_t len;
} BorrowedSlice_KeyValuePair;

/**
 * A type alias for a borrowed slice of [`KeyValuePair`]s.
 *
 * C callers can use this to pass in a slice of key-value pairs that will not
 * be freed by Rust code.
 *
 * C callers must ensure that the pointer, if not null, points to a valid slice
 * of key-value pairs of length `len`. C callers must also ensure that the slice
 * is valid for the duration of the C function call that was passed this slice.
 */
typedef struct BorrowedSlice_KeyValuePair BorrowedKeyValuePairs;

/**
 * The result type returned from an FFI function that returns no value but may
 * return an error.
 */
typedef enum VoidResult_Tag {
  /**
   * The caller provided a null pointer to the input handle.
   */
  VoidResult_NullHandlePointer,
  /**
   * The operation was successful and no error occurred.
   */
  VoidResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. Its
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  VoidResult_Err,
} VoidResult_Tag;

typedef struct VoidResult {
  VoidResult_Tag tag;
  union {
    struct {
      OwnedBytes err;
    };
  };
} VoidResult;

/**
 * A result type returned from FFI functions that retrieve a single value.
 */
typedef enum ValueResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  ValueResult_NullHandlePointer,
  /**
   * The provided root was not found in the database.
   */
  ValueResult_RevisionNotFound,
  /**
   * The provided key was not found in the database or proposal.
   */
  ValueResult_None,
  /**
   * A value was found and is returned.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this value.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  ValueResult_Some,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  ValueResult_Err,
} ValueResult_Tag;

typedef struct ValueResult {
  ValueResult_Tag tag;
  union {
    struct {
      struct HashKey revision_not_found;
    };
    struct {
      OwnedBytes some;
    };
    struct {
      OwnedBytes err;
    };
  };
} ValueResult;

/**
 * Owned version of `KeyValuePair`, returned to the FFI.
 */
typedef struct OwnedKeyValuePair {
  OwnedBytes key;
  OwnedBytes value;
} OwnedKeyValuePair;

/**
 * A result type returned from iterator FFI functions
 */
typedef enum KeyValueResult_Tag {
  /**
   * The caller provided a null pointer to an iterator handle.
   */
  KeyValueResult_NullHandlePointer,
  /**
   * The provided root was not found in the database.
   */
  KeyValueResult_RevisionNotFound,
  /**
   * The iterator returned empty result, the iterator is exhausted
   */
  KeyValueResult_None,
  /**
   * The next item on iterator is returned.
   */
  KeyValueResult_Some,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  KeyValueResult_Err,
} KeyValueResult_Tag;

typedef struct KeyValueResult {
  KeyValueResult_Tag tag;
  union {
    struct {
      struct HashKey revision_not_found;
    };
    struct {
      struct OwnedKeyValuePair some;
    };
    struct {
      OwnedBytes err;
    };
  };
} KeyValueResult;

/**
 * A result type returned from FFI functions that create an iterator
 */
typedef enum IteratorResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  IteratorResult_NullHandlePointer,
  /**
   * Building the proposal was successful and the proposal ID and root hash
   * are returned.
   */
  IteratorResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  IteratorResult_Err,
} IteratorResult_Tag;

typedef struct IteratorResult_Ok_Body {
  /**
   * An opaque pointer to the [`ProposalHandle`] that can be use to create
   * an additional proposal or later commit. The caller must ensure that this
   * pointer is freed with [`fwd_free_proposal`] if it is not committed.
   *
   * [`fwd_free_proposal`]: crate::fwd_free_proposal
   */
  struct IteratorHandle *handle;
} IteratorResult_Ok_Body;

typedef struct IteratorResult {
  IteratorResult_Tag tag;
  union {
    IteratorResult_Ok_Body ok;
    struct {
      OwnedBytes err;
    };
  };
} IteratorResult;

/**
 * The result type returned from the open or create database functions.
 */
typedef enum HandleResult_Tag {
  /**
   * The database was opened or created successfully and the handle is
   * returned as an opaque pointer.
   *
   * The caller must ensure that [`fwd_close_db`] is called to free resources
   * associated with this handle when it is no longer needed.
   *
   * [`fwd_close_db`]: crate::fwd_close_db
   */
  HandleResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  HandleResult_Err,
} HandleResult_Tag;

typedef struct HandleResult {
  HandleResult_Tag tag;
  union {
    struct {
      struct DatabaseHandle *ok;
    };
    struct {
      OwnedBytes err;
    };
  };
} HandleResult;

/**
 * Arguments for creating or opening a database. These are passed to [`fwd_open_db`]
 *
 * [`fwd_open_db`]: crate::fwd_open_db
 */
typedef struct DatabaseHandleArgs {
  /**
   * The path to the database file.
   *
   * This must be a valid UTF-8 string, even on Windows.
   *
   * If this is empty, an error will be returned.
   */
  BorrowedBytes path;
  /**
   * The size of the node cache.
   *
   * Opening returns an error if this is zero.
   */
  size_t cache_size;
  /**
   * The size of the free list cache.
   *
   * Opening returns an error if this is zero.
   */
  size_t free_list_cache_size;
  /**
   * The maximum number of revisions to keep.
   */
  size_t revisions;
  /**
   * The cache read strategy to use.
   *
   * This must be one of the following:
   *
   * - `0`: No cache.
   * - `1`: Cache only branch reads.
   * - `2`: Cache all reads.
   *
   * Opening returns an error if this is not one of the above values.
   */
  uint8_t strategy;
  /**
   * Whether to truncate the database file if it exists.
   */
  bool truncate;
} DatabaseHandleArgs;

/**
 * A result type returned from FFI functions that create a proposal but do not
 * commit it to the database.
 */
typedef enum ProposalResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  ProposalResult_NullHandlePointer,
  /**
   * Buulding the proposal was successful and the proposal ID and root hash
   * are returned.
   */
  ProposalResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  ProposalResult_Err,
} ProposalResult_Tag;

typedef struct ProposalResult_Ok_Body {
  /**
   * An opaque pointer to the [`ProposalHandle`] that can be use to create
   * an additional proposal or later commit. The caller must ensure that this
   * pointer is freed with [`fwd_free_proposal`] if it is not committed.
   *
   * [`fwd_free_proposal`]: crate::fwd_free_proposal
   */
  struct ProposalHandle *handle;
  /**
   * The root hash of the proposal. Zeroed if the proposal resulted in an
   * empty database.
   */
  struct HashKey root_hash;
} ProposalResult_Ok_Body;

typedef struct ProposalResult {
  ProposalResult_Tag tag;
  union {
    ProposalResult_Ok_Body ok;
    struct {
      OwnedBytes err;
    };
  };
} ProposalResult;

/**
 * Arguments for initializing logging for the Firewood FFI.
 */
typedef struct LogArgs {
  /**
   * The file path where logs for this process are stored.
   *
   * If empty, this is set to `${TMPDIR}/firewood-log.txt`.
   *
   * This is required to be a valid UTF-8 string.
   */
  BorrowedBytes path;
  /**
   * The filter level for logs.
   *
   * If empty, this is set to `info`.
   *
   * This is required to be a valid UTF-8 string.
   */
  BorrowedBytes filter_level;
} LogArgs;

/**
 * Puts the given key-value pairs into the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `values` - A [`BorrowedKeyValuePairs`] containing the key-value pairs to put.
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the commit resulted in an empty database.
 * - [`HashResult::Some`] if the commit was successful, containing the new root hash.
 * - [`HashResult::Err`] if an error occurred while committing the batch.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `values` is valid for [`BorrowedKeyValuePairs`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned by
 *   value).
 */
struct HashResult fwd_batch(const struct DatabaseHandle *db, BorrowedKeyValuePairs values);

/**
 * Close and free the memory for a database handle
 *
 * # Arguments
 *
 * * `db` - The database handle to close, previously returned from a call to [`fwd_open_db`].
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the provided database handle is null.
 * - [`VoidResult::Ok`] if the database handle was successfully closed and freed.
 * - [`VoidResult::Err`] if the process panics while closing the database handle.
 *
 * # Safety
 *
 * Callers must ensure that:
 *
 * - `db` is a valid pointer to a [`DatabaseHandle`] returned by [`fwd_open_db`].
 * - There are no handles to any open proposals. If so, they must be freed first
 *   using [`fwd_free_proposal`].
 * - The database handle is not used after this function is called.
 */
struct VoidResult fwd_close_db(struct DatabaseHandle *db);

/**
 * Commits a proposal to the database.
 *
 * This function will consume the proposal regardless of whether the commit
 * is successful.
 *
 * # Arguments
 *
 * * `handle` - The proposal handle returned by [`fwd_propose_on_db`] or
 *   [`fwd_propose_on_proposal`].
 *
 * # Returns
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the commit resulted in an empty database.
 * - [`HashResult::Some`] if the commit was successful, containing the new root hash.
 * - [`HashResult::Err`] if an error occurred while committing the batch.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`ProposalHandle`]
 * * ensure that `handle` is not used again after this function is called.
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned
 *   by value).
 */
struct HashResult fwd_commit_proposal(struct ProposalHandle *proposal);

/**
 * Consumes the [`IteratorHandle`], destroys the iterator, and frees the memory.
 *
 * # Arguments
 *
 * * `iterator` - A pointer to a [`IteratorHandle`] previously returned from a
 *   function from this library.
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the provided iterator handle is null.
 * - [`VoidResult::Ok`] if the iterator was successfully freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 *
 * # Safety
 *
 * The caller must ensure that the `iterator` is not null and that it points to
 * a valid [`IteratorHandle`] previously returned by a function from this library.
 *
 */
struct VoidResult fwd_free_iterator(struct IteratorHandle *iterator);

/**
 * Consumes the [`OwnedBytes`] and frees the memory associated with it.
 *
 * # Arguments
 *
 * * `bytes` - The [`OwnedBytes`] struct to free, previously returned from any
 *   function from this library.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the memory was successfully freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 *
 * # Safety
 *
 * The caller must ensure that the `bytes` struct is valid and that the memory
 * it points to is uniquely owned by this object. However, if `bytes.ptr` is null,
 * this function does nothing.
 */
struct VoidResult fwd_free_owned_bytes(OwnedBytes bytes);

/**
 * Consumes the [`ProposalHandle`], cancels the proposal, and frees the memory.
 *
 * # Arguments
 *
 * * `proposal` - A pointer to a [`ProposalHandle`] previously returned from a
 *   function from this library.
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the provided proposal handle is null.
 * - [`VoidResult::Ok`] if the proposal was successfully cancelled and freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 *
 * # Safety
 *
 * The caller must ensure that the `proposal` is not null and that it points to
 * a valid [`ProposalHandle`] previously returned by a function from this library.
 *
 * The caller must ensure that the proposal was not committed. [`fwd_commit_proposal`]
 * will consume the proposal automatically.
 */
struct VoidResult fwd_free_proposal(struct ProposalHandle *proposal);

/**
 * Gather latest metrics for this process.
 *
 * # Returns
 *
 * - [`ValueResult::None`] if the gathered metrics resulted in an empty string.
 * - [`ValueResult::Some`] the gathered metrics as an [`OwnedBytes`] (with
 *   guaranteed to be utf-8 data, not null terminated).
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error or value.
 */
struct ValueResult fwd_gather(void);

/**
 * Gets the value associated with the given key from the proposal provided.
 *
 * # Arguments
 *
 * * `handle` - The proposal handle returned by [`fwd_propose_on_db`] or
 *   [`fwd_propose_on_proposal`].
 * * `key` - The key to look up, as a [`BorrowedBytes`].
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ValueResult::None`] if the key was not found.
 * - [`ValueResult::Some`] if the key was found with the associated value.
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`ProposalHandle`]
 * * ensure that `key` is valid for [`BorrowedBytes`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated [`OwnedBytes`]
 *   returned in the result.
 */
struct ValueResult fwd_get_from_proposal(const struct ProposalHandle *handle, BorrowedBytes key);

/**
 * Gets a value assoicated with the given root hash and key.
 *
 * The hash may refer to a historical revision or an existing proposal.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `root` - The root hash to look up as a [`BorrowedBytes`]
 * * `key` - The key to look up as a [`BorrowedBytes`]
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ValueResult::RevisionNotFound`] if no revision was found for the specified root.
 * - [`ValueResult::None`] if the key was not found.
 * - [`ValueResult::Some`] if the key was found with the associated value.
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `root` is a valid for [`BorrowedBytes`]
 * * ensure that `key` is a valid for [`BorrowedBytes`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated [`OwnedBytes`]
 *   returned in the result.
 */
struct ValueResult fwd_get_from_root(const struct DatabaseHandle *db,
                                     BorrowedBytes root,
                                     BorrowedBytes key);

/**
 * Gets the value associated with the given key from the database for the
 * latest revision.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `key` - The key to look up as a [`BorrowedBytes`]
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ValueResult::RevisionNotFound`] if no revision was found for the root
 *   (i.e., there is no current root).
 * - [`ValueResult::None`] if the key was not found.
 * - [`ValueResult::Some`] if the key was found with the associated value.
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`].
 * * ensure that `key` is valid for [`BorrowedBytes`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error or value.
 *
 * [`BorrowedBytes`]: crate::value::BorrowedBytes
 */
struct ValueResult fwd_get_latest(const struct DatabaseHandle *db, BorrowedBytes key);

/**
 * Retrieves the next item from the iterator
 *
 * # Arguments
 *
 * * `handle` - The iterator handle returned by [`fwd_iter_on_root`] or
 *   [`fwd_iter_on_proposal`].
 *
 * # Returns
 *
 * - [`KeyValueResult::NullHandlePointer`] if the provided iterator handle is null.
 * - [`KeyValueResult::None`] if the iterator doesn't have any remaining values/exhausted.
 * - [`KeyValueResult::Some`] if the next item on iterator was retrieved, with the associated
 *   key value pair.
 * - [`KeyValueResult::Err`] if an error occurred while retrieving the next item on iterator.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`IteratorHandle`].
 * * call [`fwd_free_owned_bytes`] on [`OwnedKeyValuePair::key`] and [`OwnedKeyValuePair::value`]
 *   to free the memory associated with the returned error or value.
 *
 */
struct KeyValueResult fwd_iter_next(struct IteratorHandle *handle);

/**
 * Return an iterator on proposal optionally starting from a key
 *
 * # Arguments
 *
 * * `handle` - The proposal handle returned by [`fwd_propose_on_db`] or
 *   [`fwd_propose_on_proposal`].
 * * `key` - The key to look up as a [`BorrowedBytes`]
 *
 * # Returns
 *
 * - [`IteratorResult::NullHandlePointer`] if the provided proposal handle is null.
 * - [`IteratorResult::Ok`] if the iterator was created, with the iterator handle.
 * - [`IteratorResult::Err`] if an error occurred while creating the iterator.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`ProposalHandle`]
 * * ensure that `key` is a valid for [`BorrowedBytes`]
 * * call [`fwd_free_iterator`] to free the memory associated with the iterator.
 *
 */
struct IteratorResult fwd_iter_on_proposal(const struct ProposalHandle *handle, BorrowedBytes key);

/**
 * Return an iterator optionally starting from a key in database
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `root` - The root hash to look up as a [`BorrowedBytes`]
 * * `key` - The key to look up as a [`BorrowedBytes`]
 *
 * # Returns
 *
 * - [`IteratorResult::NullHandlePointer`] if the provided database handle is null.
 * - [`IteratorResult::Ok`] if the iterator was created, with the iterator handle.
 * - [`IteratorResult::Err`] if an error occurred while creating the iterator.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `root` is a valid for [`BorrowedBytes`]
 * * ensure that `key` is a valid for [`BorrowedBytes`]
 * * call [`fwd_free_iterator`] to free the memory associated with the iterator.
 *
 */
struct IteratorResult fwd_iter_on_root(const struct DatabaseHandle *db,
                                       BorrowedBytes root,
                                       BorrowedBytes key);

/**
 * Open a database with the given arguments.
 *
 * # Arguments
 *
 * See [`DatabaseHandleArgs`].
 *
 * # Returns
 *
 * - [`HandleResult::Ok`] with the database handle if successful.
 * - [`HandleResult::Err`] if an error occurs while opening the database.
 *
 * # Safety
 *
 * The caller must:
 * - ensure that the database is freed with [`fwd_close_db`] when no longer needed.
 * - ensure that the database handle is freed only after freeing or committing
 *   all proposals created on it.
 */
struct HandleResult fwd_open_db(struct DatabaseHandleArgs args);

/**
 * Proposes a batch of operations to the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `values` - A [`BorrowedKeyValuePairs`] containing the key-value pairs to put.
 *
 * # Returns
 *
 * - [`ProposalResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ProposalResult::Ok`] if the proposal was created, with the proposal handle
 *   and calculated root hash.
 * - [`ProposalResult::Err`] if an error occurred while creating the proposal.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `values` is valid for [`BorrowedKeyValuePairs`]
 * * call [`fwd_commit_proposal`] or [`fwd_free_proposal`] to free the memory
 *   associated with the proposal. And, the caller must ensure this is done
 *   before calling [`fwd_close_db`] to avoid memory leaks or undefined behavior.
 */
struct ProposalResult fwd_propose_on_db(const struct DatabaseHandle *db,
                                        BorrowedKeyValuePairs values);

/**
 * Proposes a batch of operations to the database on top of an existing proposal.
 *
 * # Arguments
 *
 * * `handle` - The proposal handle returned by [`fwd_propose_on_db`] or
 *   [`fwd_propose_on_proposal`].
 * * `values` - A [`BorrowedKeyValuePairs`] containing the key-value pairs to put.
 *
 * # Returns
 *
 * - [`ProposalResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ProposalResult::Ok`] if the proposal was created, with the proposal handle
 *   and calculated root hash.
 * - [`ProposalResult::Err`] if an error occurred while creating the proposal.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`ProposalHandle`]
 * * ensure that `values` is valid for [`BorrowedKeyValuePairs`]
 * * call [`fwd_commit_proposal`] or [`fwd_free_proposal`] to free the memory
 *   associated with the proposal. And, the caller must ensure this is done
 *   before calling [`fwd_close_db`] to avoid memory leaks or undefined behavior.
 */
struct ProposalResult fwd_propose_on_proposal(const struct ProposalHandle *handle,
                                              BorrowedKeyValuePairs values);

/**
 * Get the root hash of the latest version of the database
 *
 * # Argument
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the database is empty.
 * - [`HashResult::Some`] with the root hash of the database.
 * - [`HashResult::Err`] if an error occurred while looking up the root hash.
 *
 * # Safety
 *
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned
 *   by value).
 */
struct HashResult fwd_root_hash(const struct DatabaseHandle *db);

/**
 * Start logs for this process.
 *
 * # Arguments
 *
 * See [`LogArgs`].
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error (if any).
 */
struct VoidResult fwd_start_logs(struct LogArgs args);

/**
 * Start metrics recorder for this process.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 */
struct VoidResult fwd_start_metrics(void);

/**
 * Start metrics recorder and exporter for this process.
 *
 * # Arguments
 *
 * * `metrics_port` - the port where metrics will be exposed at
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error (if any).
 */
struct VoidResult fwd_start_metrics_with_exporter(uint16_t metrics_port);
