// Copyright (C) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE.md for licensing terms.

// This file was @generated by cbindgen. Do not edit this file manually.
// Run `cargo build --target firewood-ffi` to regenerate this file.

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * FFI context for a parsed or generated change proof.
 */
typedef struct ChangeProofContext ChangeProofContext;

/**
 * A handle to the database, returned by `fwd_open_db`.
 *
 * These handles are passed to the other FFI functions.
 *
 */
typedef struct DatabaseHandle DatabaseHandle;

/**
 * An opaque wrapper around a Proposal that also retains a reference to the
 * database handle it was created from.
 */
typedef struct ProposalHandle ProposalHandle;

/**
 * FFI context for for a parsed or generated range proof.
 */
typedef struct RangeProofContext RangeProofContext;

/**
 * A database hash key, used in FFI functions that require hashes.
 * This type requires no allocation and can be copied freely and
 * dropped without any additional overhead.
 *
 * This is useful because it is the same size as 4 words which is equivalent
 * to 2 heap-allocated slices (pointer + length each), or 1.5 vectors (which
 * uses an extra word for allocation capacity) and it can be passed around
 * without needing to allocate or deallocate memory.
 */
typedef struct HashKey {
  uint8_t _0[32];
} HashKey;

/**
 * A Rust-owned vector of bytes that can be passed to C code.
 *
 * C callers must free this memory using the respective FFI function for the
 * concrete type (but not using the `free` function from the C standard library).
 */
typedef struct OwnedSlice_u8 {
  uint8_t *ptr;
  size_t len;
} OwnedSlice_u8;

/**
 * A type alias for a rust-owned byte slice.
 */
typedef struct OwnedSlice_u8 OwnedBytes;

/**
 * A result type returned from FFI functions return the database root hash. This
 * may or may not be after a mutation.
 */
typedef enum HashResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  HashResult_NullHandlePointer,
  /**
   * The proposal resulted in an empty database or the database currently has
   * no root hash.
   */
  HashResult_None,
  /**
   * The mutation was successful and the root hash is returned, if this result
   * was from a mutation. Otherwise, this is the current root hash of the
   * database.
   */
  HashResult_Some,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  HashResult_Err,
} HashResult_Tag;

typedef struct HashResult {
  HashResult_Tag tag;
  union {
    struct {
      struct HashKey some;
    };
    struct {
      OwnedBytes err;
    };
  };
} HashResult;

/**
 * A borrowed byte slice. Used to represent data that was passed in from C
 * callers and will not be freed or retained by Rust code.
 */
typedef struct BorrowedSlice_u8 {
  /**
   * A pointer to the slice of bytes. This can be null if the slice is empty.
   *
   * If the pointer is not null, it must point to a valid slice of `len`
   * elements sized and aligned for `T`.
   *
   * As a note, [`NonNull`] is not appropriate here because [`NonNull`] pointer
   * provenance requires mutable access to the pointer, which is not an invariant
   * we want to enforce here. We want (and require) the pointer to be immutable.
   *
   * [`NonNull`]: std::ptr::NonNull
   */
  const uint8_t *ptr;
  /**
   * The length of the slice. It is ignored if the pointer is null; however,
   * if the pointer is not null, it must be equal to the number of elements
   * pointed to by `ptr`.
   */
  size_t len;
} BorrowedSlice_u8;

/**
 * A type alias for a borrowed byte slice.
 *
 * C callers can use this to pass in a byte slice that will not be freed by Rust
 * code.
 *
 * C callers must ensure that the pointer, if not null, points to a valid slice
 * of bytes of length `len`. C callers must also ensure that the slice is valid
 * for the duration of the C function call that was passed this slice.
 */
typedef struct BorrowedSlice_u8 BorrowedBytes;

/**
 * A `KeyValue` represents a key-value pair, passed to the FFI.
 */
typedef struct KeyValuePair {
  BorrowedBytes key;
  BorrowedBytes value;
} KeyValuePair;

/**
 * A borrowed byte slice. Used to represent data that was passed in from C
 * callers and will not be freed or retained by Rust code.
 */
typedef struct BorrowedSlice_KeyValuePair {
  /**
   * A pointer to the slice of bytes. This can be null if the slice is empty.
   *
   * If the pointer is not null, it must point to a valid slice of `len`
   * elements sized and aligned for `T`.
   *
   * As a note, [`NonNull`] is not appropriate here because [`NonNull`] pointer
   * provenance requires mutable access to the pointer, which is not an invariant
   * we want to enforce here. We want (and require) the pointer to be immutable.
   *
   * [`NonNull`]: std::ptr::NonNull
   */
  const struct KeyValuePair *ptr;
  /**
   * The length of the slice. It is ignored if the pointer is null; however,
   * if the pointer is not null, it must be equal to the number of elements
   * pointed to by `ptr`.
   */
  size_t len;
} BorrowedSlice_KeyValuePair;

/**
 * A type alias for a borrowed slice of [`KeyValuePair`]s.
 *
 * C callers can use this to pass in a slice of key-value pairs that will not
 * be freed by Rust code.
 *
 * C callers must ensure that the pointer, if not null, points to a valid slice
 * of key-value pairs of length `len`. C callers must also ensure that the slice
 * is valid for the duration of the C function call that was passed this slice.
 */
typedef struct BorrowedSlice_KeyValuePair BorrowedKeyValuePairs;

/**
 * Maybe is a C-compatible optional type using a tagged union pattern.
 *
 * FFI methods and types can use this to represent optional values where `Optional<T>`
 * does not work due to it not having a C-compatible layout.
 */
typedef enum Maybe_OwnedBytes_Tag {
  /**
   * No value present.
   */
  Maybe_OwnedBytes_None_OwnedBytes,
  /**
   * A value is present.
   */
  Maybe_OwnedBytes_Some_OwnedBytes,
} Maybe_OwnedBytes_Tag;

typedef struct Maybe_OwnedBytes {
  Maybe_OwnedBytes_Tag tag;
  union {
    struct {
      OwnedBytes some;
    };
  };
} Maybe_OwnedBytes;

/**
 * A key range that should be fetched to continue iterating through a range
 * or change proof that was truncated. Represents a half-open range
 * `[start_key, end_key)`. If `end_key` is `None`, the range is unbounded
 * and continues to the end of the keyspace.
 */
typedef struct NextKeyRange {
  /**
   * The start key of the next range to fetch.
   */
  OwnedBytes start_key;
  /**
   * If set, a non-inclusive upper bound for the next range to fetch. If not
   * set, the range is unbounded (this is the final range).
   */
  struct Maybe_OwnedBytes end_key;
} NextKeyRange;

typedef enum NextKeyRangeResult_Tag {
  /**
   * The caller provided a null pointer to the input handle.
   */
  NextKeyRangeResult_NullHandlePointer,
  /**
   * The proof has not prepared into a proposal nor committed to the database.
   */
  NextKeyRangeResult_NotPrepared,
  /**
   * There are no more keys to fetch.
   */
  NextKeyRangeResult_None,
  /**
   * The next key range to fetch is returned.
   */
  NextKeyRangeResult_Some,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  NextKeyRangeResult_Err,
} NextKeyRangeResult_Tag;

typedef struct NextKeyRangeResult {
  NextKeyRangeResult_Tag tag;
  union {
    struct {
      struct NextKeyRange some;
    };
    struct {
      OwnedBytes err;
    };
  };
} NextKeyRangeResult;

/**
 * A result type returned from FFI functions that create or parse change proofs.
 *
 * The caller must ensure that [`fwd_free_change_proof`] is called to
 * free the memory associated with the returned context when it is no longer
 * needed.
 *
 * [`fwd_free_change_proof`]: crate::fwd_free_change_proof
 */
typedef enum ChangeProofResult_Tag {
  /**
   * The caller provided a null pointer to the input handle.
   */
  ChangeProofResult_NullHandlePointer,
  /**
   * The provided root was not found in the database.
   */
  ChangeProofResult_RevisionNotFound,
  /**
   * The proof was successfully created or parsed.
   *
   * If the value was parsed from a serialized proof, this does not imply that
   * the proof is valid, only that it is well-formed. The verify method must
   * be called to ensure the proof is cryptographically valid.
   */
  ChangeProofResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  ChangeProofResult_Err,
} ChangeProofResult_Tag;

typedef struct ChangeProofResult {
  ChangeProofResult_Tag tag;
  union {
    struct {
      struct HashKey revision_not_found;
    };
    struct {
      struct ChangeProofContext *ok;
    };
    struct {
      OwnedBytes err;
    };
  };
} ChangeProofResult;

/**
 * A result type returned from FFI functions that retrieve a single value.
 */
typedef enum ValueResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  ValueResult_NullHandlePointer,
  /**
   * The provided root was not found in the database.
   */
  ValueResult_RevisionNotFound,
  /**
   * The provided key was not found in the database or proposal.
   */
  ValueResult_None,
  /**
   * A value was found and is returned.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this value.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  ValueResult_Some,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  ValueResult_Err,
} ValueResult_Tag;

typedef struct ValueResult {
  ValueResult_Tag tag;
  union {
    struct {
      struct HashKey revision_not_found;
    };
    struct {
      OwnedBytes some;
    };
    struct {
      OwnedBytes err;
    };
  };
} ValueResult;

/**
 * The result type returned from an FFI function that returns no value but may
 * return an error.
 */
typedef enum VoidResult_Tag {
  /**
   * The caller provided a null pointer to the input handle.
   */
  VoidResult_NullHandlePointer,
  /**
   * The operation was successful and no error occurred.
   */
  VoidResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. Its
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  VoidResult_Err,
} VoidResult_Tag;

typedef struct VoidResult {
  VoidResult_Tag tag;
  union {
    struct {
      OwnedBytes err;
    };
  };
} VoidResult;

/**
 * Maybe is a C-compatible optional type using a tagged union pattern.
 *
 * FFI methods and types can use this to represent optional values where `Optional<T>`
 * does not work due to it not having a C-compatible layout.
 */
typedef enum Maybe_BorrowedBytes_Tag {
  /**
   * No value present.
   */
  Maybe_BorrowedBytes_None_BorrowedBytes,
  /**
   * A value is present.
   */
  Maybe_BorrowedBytes_Some_BorrowedBytes,
} Maybe_BorrowedBytes_Tag;

typedef struct Maybe_BorrowedBytes {
  Maybe_BorrowedBytes_Tag tag;
  union {
    struct {
      BorrowedBytes some;
    };
  };
} Maybe_BorrowedBytes;

/**
 * Arguments for creating a change proof.
 */
typedef struct CreateChangeProofArgs {
  /**
   * The root hash of the starting revision. This must be provided.
   * If the root is not found in the database, the function will return
   * [`ChangeProofResult::RevisionNotFound`].
   */
  BorrowedBytes start_root;
  /**
   * The root hash of the ending revision. This must be provided.
   * If the root is not found in the database, the function will return
   * [`ChangeProofResult::RevisionNotFound`].
   */
  BorrowedBytes end_root;
  /**
   * The start key of the range to create the proof for. If `None`, the range
   * starts from the beginning of the keyspace.
   */
  struct Maybe_BorrowedBytes start_key;
  /**
   * The end key of the range to create the proof for. If `None`, the range
   * ends at the end of the keyspace or until `max_length` items have been
   * included in the proof.
   */
  struct Maybe_BorrowedBytes end_key;
  /**
   * The maximum number of key/value pairs to include in the proof. If the
   * range contains more items than this, the proof will be truncated. If
   * `0`, there is no limit.
   */
  uint32_t max_length;
} CreateChangeProofArgs;

/**
 * A result type returned from FFI functions that create or parse range proofs.
 *
 * The caller must ensure that [`fwd_free_range_proof`] is called to
 * free the memory associated with the returned context when it is no longer
 * needed.
 *
 * [`fwd_free_range_proof`]: crate::fwd_free_range_proof
 */
typedef enum RangeProofResult_Tag {
  /**
   * The caller provided a null pointer to the input handle.
   */
  RangeProofResult_NullHandlePointer,
  /**
   * The provided root was not found in the database.
   */
  RangeProofResult_RevisionNotFound,
  /**
   * A range proof was requested on an empty trie.
   */
  RangeProofResult_EmptyTrie,
  /**
   * The proof was successfully created or parsed.
   *
   * If the value was parsed from a serialized proof, this does not imply that
   * the proof is valid, only that it is well-formed. The verify method must
   * be called to ensure the proof is cryptographically valid.
   */
  RangeProofResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  RangeProofResult_Err,
} RangeProofResult_Tag;

typedef struct RangeProofResult {
  RangeProofResult_Tag tag;
  union {
    struct {
      struct HashKey revision_not_found;
    };
    struct {
      struct RangeProofContext *ok;
    };
    struct {
      OwnedBytes err;
    };
  };
} RangeProofResult;

/**
 * Arguments for creating a range proof.
 */
typedef struct CreateRangeProofArgs {
  /**
   * The root hash of the revision to prove. If `None`, the latest revision
   * is used.
   */
  struct Maybe_BorrowedBytes root;
  /**
   * The start key of the range to prove. If `None`, the range starts from the
   * beginning of the keyspace.
   *
   * The start key must be less than the end key if both are provided.
   */
  struct Maybe_BorrowedBytes start_key;
  /**
   * The end key of the range to prove. If `None`, the range ends at the end
   * of the keyspace or until `max_length` items have been been included in
   * the proof.
   *
   * If provided, end key is inclusive if not truncated. Otherwise, the end
   * key will be the final key in the returned key-value pairs.
   */
  struct Maybe_BorrowedBytes end_key;
  /**
   * The maximum number of key/value pairs to include in the proof. If the
   * range contains more items than this, the proof will be truncated. If
   * `0`, there is no limit.
   */
  uint32_t max_length;
} CreateRangeProofArgs;

/**
 * Arguments for verifying a change proof.
 */
typedef struct VerifyChangeProofArgs {
  /**
   * The change proof to verify. If null, the function will return
   * [`VoidResult::NullHandlePointer`]. We need a mutable reference to
   * update the validation context.
   */
  struct ChangeProofContext *proof;
  /**
   * The root hash of the starting revision. This must match the starting
   * root of the proof.
   */
  BorrowedBytes start_root;
  /**
   * The root hash of the ending revision. This must match the ending root of
   * the proof.
   */
  BorrowedBytes end_root;
  /**
   * The lower bound of the key range that the proof is expected to cover. If
   * `None`, the proof is expected to cover from the start of the keyspace.
   */
  struct Maybe_BorrowedBytes start_key;
  /**
   * The upper bound of the key range that the proof is expected to cover. If
   * `None`, the proof is expected to cover to the end of the keyspace.
   */
  struct Maybe_BorrowedBytes end_key;
  /**
   * The maximum number of key/value pairs that the proof is expected to cover.
   * If the proof contains more items than this, it is considered invalid. If
   * `0`, there is no limit.
   */
  uint32_t max_length;
} VerifyChangeProofArgs;

/**
 * Arguments for verifying a range proof.
 */
typedef struct VerifyRangeProofArgs {
  /**
   * The range proof to verify. If null, the function will return
   * [`VoidResult::NullHandlePointer`]. We need a mutable reference to
   * update the validation context.
   */
  struct RangeProofContext *proof;
  /**
   * The root hash to verify the proof against. This must match the calculated
   * hash of the root of the proof.
   */
  BorrowedBytes root;
  /**
   * The lower bound of the key range that the proof is expected to cover. If
   * `None`, the proof is expected to cover from the start of the keyspace.
   *
   * Must be present if the range proof contains a lower bound proof and must
   * be absent if the range proof does not contain a lower bound proof.
   */
  struct Maybe_BorrowedBytes start_key;
  /**
   * The upper bound of the key range that the proof is expected to cover. If
   * `None`, the proof is expected to cover to the end of the keyspace.
   *
   * This is ignored if the proof is truncated and does not cover the full,
   * in which case the upper bound key is the final key in the key-value pairs.
   */
  struct Maybe_BorrowedBytes end_key;
  /**
   * The maximum number of key/value pairs that the proof is expected to cover.
   * If the proof contains more items than this, it is considered invalid. If
   * `0`, there is no limit.
   */
  uint32_t max_length;
} VerifyRangeProofArgs;

/**
 * The result type returned from the open or create database functions.
 */
typedef enum HandleResult_Tag {
  /**
   * The database was opened or created successfully and the handle is
   * returned as an opaque pointer.
   *
   * The caller must ensure that [`fwd_close_db`] is called to free resources
   * associated with this handle when it is no longer needed.
   *
   * [`fwd_close_db`]: crate::fwd_close_db
   */
  HandleResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  HandleResult_Err,
} HandleResult_Tag;

typedef struct HandleResult {
  HandleResult_Tag tag;
  union {
    struct {
      struct DatabaseHandle *ok;
    };
    struct {
      OwnedBytes err;
    };
  };
} HandleResult;

/**
 * Arguments for creating or opening a database. These are passed to [`fwd_open_db`]
 *
 * [`fwd_open_db`]: crate::fwd_open_db
 */
typedef struct DatabaseHandleArgs {
  /**
   * The path to the database file.
   *
   * This must be a valid UTF-8 string, even on Windows.
   *
   * If this is empty, an error will be returned.
   */
  BorrowedBytes path;
  /**
   * The size of the node cache.
   *
   * Opening returns an error if this is zero.
   */
  size_t cache_size;
  /**
   * The size of the free list cache.
   *
   * Opening returns an error if this is zero.
   */
  size_t free_list_cache_size;
  /**
   * The maximum number of revisions to keep.
   */
  size_t revisions;
  /**
   * The cache read strategy to use.
   *
   * This must be one of the following:
   *
   * - `0`: No cache.
   * - `1`: Cache only branch reads.
   * - `2`: Cache all reads.
   *
   * Opening returns an error if this is not one of the above values.
   */
  uint8_t strategy;
  /**
   * Whether to truncate the database file if it exists.
   */
  bool truncate;
} DatabaseHandleArgs;

/**
 * A result type returned from FFI functions that create a proposal but do not
 * commit it to the database.
 */
typedef enum ProposalResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  ProposalResult_NullHandlePointer,
  /**
   * Buulding the proposal was successful and the proposal ID and root hash
   * are returned.
   */
  ProposalResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  ProposalResult_Err,
} ProposalResult_Tag;

typedef struct ProposalResult_Ok_Body {
  /**
   * An opaque pointer to the [`ProposalHandle`] that can be use to create
   * an additional proposal or later commit. The caller must ensure that this
   * pointer is freed with [`fwd_free_proposal`] if it is not committed.
   *
   * [`fwd_free_proposal`]: crate::fwd_free_proposal
   */
  struct ProposalHandle *handle;
  /**
   * The root hash of the proposal. Zeroed if the proposal resulted in an
   * empty database.
   */
  struct HashKey root_hash;
} ProposalResult_Ok_Body;

typedef struct ProposalResult {
  ProposalResult_Tag tag;
  union {
    ProposalResult_Ok_Body ok;
    struct {
      OwnedBytes err;
    };
  };
} ProposalResult;

/**
 * Arguments for initializing logging for the Firewood FFI.
 */
typedef struct LogArgs {
  /**
   * The file path where logs for this process are stored.
   *
   * If empty, this is set to `${TMPDIR}/firewood-log.txt`.
   *
   * This is required to be a valid UTF-8 string.
   */
  BorrowedBytes path;
  /**
   * The filter level for logs.
   *
   * If empty, this is set to `info`.
   *
   * This is required to be a valid UTF-8 string.
   */
  BorrowedBytes filter_level;
} LogArgs;

/**
 * Puts the given key-value pairs into the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `values` - A [`BorrowedKeyValuePairs`] containing the key-value pairs to put.
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the commit resulted in an empty database.
 * - [`HashResult::Some`] if the commit was successful, containing the new root hash.
 * - [`HashResult::Err`] if an error occurred while committing the batch.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `values` is valid for [`BorrowedKeyValuePairs`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned by
 *   value).
 */
struct HashResult fwd_batch(const struct DatabaseHandle *db, BorrowedKeyValuePairs values);

/**
 * Returns the next key range that should be fetched after processing the
 * current set of operations in a change proof that was truncated.
 *
 * Can be called multiple times to get subsequent disjoint key ranges until
 * it returns [`NextKeyRangeResult::None`], indicating there are no more keys to
 * fetch and the proof is complete.
 *
 * # Arguments
 *
 * - `proof` - A [`ChangeProofContext`] previously returned from the create
 *   methods and has been prepared into a proposal or already committed.
 *
 * # Returns
 *
 * - [`NextKeyRangeResult::NullHandlePointer`] if the caller provided a null pointer.
 * - [`NextKeyRangeResult::NotPrepared`] if the proof has not been prepared into
 *   a proposal nor committed to the database.
 * - [`NextKeyRangeResult::None`] if there are no more keys to fetch.
 * - [`NextKeyRangeResult::Some`] containing the next key range to fetch.
 * - [`NextKeyRangeResult::Err`] containing an error message if the next key range
 *   could not be determined.
 *
 * # Thread Safety
 *
 * It is not safe to call this function concurrently with the same proof context
 * nor is it safe to call any other function that accesses the same proof context
 * concurrently. The caller must ensure exclusive access to the proof context
 * for the duration of the call.
 */
struct NextKeyRangeResult fwd_change_proof_find_next_key(struct ChangeProofContext *_proof);

/**
 * Deserialize a `ChangeProof` from bytes.
 *
 * # Arguments
 *
 * * `bytes` - The bytes to deserialize the proof from.
 *
 * # Returns
 *
 * - [`ChangeProofResult::NullHandlePointer`] if the caller provided a null or zero-length slice.
 * - [`ChangeProofResult::Ok`] containing a pointer to the `ChangeProofContext` if the proof
 *   was successfully parsed. This does not imply that the proof is valid, only that it is
 *   well-formed. The verify method must be called to ensure the proof is cryptographically valid.
 * - [`ChangeProofResult::Err`] containing an error message if the proof could not be parsed.
 */
struct ChangeProofResult fwd_change_proof_from_bytes(BorrowedBytes _bytes);

/**
 * Serialize a `ChangeProof` to bytes.
 *
 * # Arguments
 *
 * - `proof` - A [`ChangeProofContext`] previously returned from the create
 *   method. If from a parsed proof, the proof will not be verified before
 *   serialization.
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the caller provided a null pointer.
 * - [`ValueResult::Some`] containing the serialized bytes if successful.
 * - [`ValueResult::Err`] if the caller provided a null pointer.
 *
 * The other [`ValueResult`] variants are not used.
 */
struct ValueResult fwd_change_proof_to_bytes(const struct ChangeProofContext *_proof);

/**
 * Close and free the memory for a database handle
 *
 * # Arguments
 *
 * * `db` - The database handle to close, previously returned from a call to [`fwd_open_db`].
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the provided database handle is null.
 * - [`VoidResult::Ok`] if the database handle was successfully closed and freed.
 * - [`VoidResult::Err`] if the process panics while closing the database handle.
 *
 * # Safety
 *
 * Callers must ensure that:
 *
 * - `db` is a valid pointer to a [`DatabaseHandle`] returned by [`fwd_open_db`].
 * - There are no handles to any open proposals. If so, they must be freed first
 *   using [`fwd_free_proposal`].
 * - The database handle is not used after this function is called.
 */
struct VoidResult fwd_close_db(struct DatabaseHandle *db);

/**
 * Commits a proposal to the database.
 *
 * This function will consume the proposal regardless of whether the commit
 * is successful.
 *
 * # Arguments
 *
 * * `handle` - The proposal handle returned by [`fwd_propose_on_db`] or
 *   [`fwd_propose_on_proposal`].
 *
 * # Returns
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the commit resulted in an empty database.
 * - [`HashResult::Some`] if the commit was successful, containing the new root hash.
 * - [`HashResult::Err`] if an error occurred while committing the batch.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`ProposalHandle`]
 * * ensure that `handle` is not used again after this function is called.
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned
 *   by value).
 */
struct HashResult fwd_commit_proposal(struct ProposalHandle *proposal);

/**
 * Create a change proof for the given range of keys between two roots.
 *
 * # Arguments
 *
 * - `db` - The database to create the proof from.
 * - `args` - The arguments for creating the change proof.
 *
 * # Returns
 *
 * - [`ChangeProofResult::NullHandlePointer`] if the caller provided a null pointer.
 * - [`ChangeProofResult::RevisionNotFound`] if the caller provided a start or end root
 *   that was not found in the database. The missing root hash is included in the result.
 *   The start root is checked first, and if both are missing, only the start root is
 *   reported.
 * - [`ChangeProofResult::Ok`] containing a pointer to the `ChangeProofContext` if the proof
 *   was successfully created.
 * - [`ChangeProofResult::Err`] containing an error message if the proof could not be created.
 */
struct ChangeProofResult fwd_db_change_proof(const struct DatabaseHandle *_db,
                                             struct CreateChangeProofArgs _args);

/**
 * Generate a range proof for the given range of keys for the latest revision.
 *
 * # Arguments
 *
 * - `db` - The database to create the proof from.
 * - `args` - The arguments for creating the range proof.
 *
 * # Returns
 *
 * - [`RangeProofResult::NullHandlePointer`] if the caller provided a null pointer.
 * - [`RangeProofResult::RevisionNotFound`] if the caller provided a root that was
 *   not found in the database. The missing root hash is included in the result.
 * - [`RangeProofResult::Ok`] containing a pointer to the `RangeProofContext` if the proof
 *   was successfully created.
 * - [`RangeProofResult::Err`] containing an error message if the proof could not be created.
 */
struct RangeProofResult fwd_db_range_proof(const struct DatabaseHandle *db,
                                           struct CreateRangeProofArgs args);

/**
 * Verify and commit a change proof to the database.
 *
 * If the proof has already been verified, the previously prepared proposal will be
 * committed instead of re-verifying. If the proof has not been verified, it will be
 * verified now. If the prepared proposal is no longer valid (e.g., the database has
 * changed since it was prepared), a new proposal will be created and committed.
 *
 * The proof context will be updated with additional information about the committed
 * proof to allow for optimized introspection of the committed changes.
 *
 * # Arguments
 *
 * - `db` - The database to commit the changes to.
 * - `args` - The arguments for verifying the change proof.
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the caller provided a null pointer to either
 *   the database or the proof.
 * - [`HashResult::None`] if the proof resulted in an empty database (i.e., all keys were deleted).
 * - [`HashResult::Some`] containing the new root hash if the proof was successfully verified
 * - [`HashResult::Err`] containing an error message if the proof could not be verified or committed.
 *
 * # Thread Safety
 *
 * It is not safe to call this function concurrently with the same proof context
 * nor is it safe to call any other function that accesses the same proof context
 * concurrently. The caller must ensure exclusive access to the proof context
 * for the duration of the call.
 */
struct HashResult fwd_db_verify_and_commit_change_proof(const struct DatabaseHandle *_db,
                                                        struct VerifyChangeProofArgs _args);

/**
 * Verify and commit a range proof to the database.
 *
 * If a proposal was previously prepared by a call to [`fwd_db_verify_range_proof`],
 * it will be committed instead of re-verifying the proof. If the proof has not yet
 * been verified, it will be verified now. If the prepared proposal is no longer
 * valid (e.g., the database has changed since it was prepared), a new proposal
 * will be created and committed.
 *
 * The proof context will be updated with additional information about the committed
 * proof to allow for optimized introspection of the committed changes.
 *
 * # Arguments
 *
 * - `db` - The database to commit the changes to.
 * - `args` - The arguments for verifying the range proof.
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the caller provided a null pointer to either
 *   the database or the proof.
 * - [`HashResult::None`] if the proof resulted in an empty database (i.e., all keys were deleted).
 * - [`HashResult::Some`] containing the new root hash if the proof was successfully verified
 * - [`HashResult::Err`] containing an error message if the proof could not be verified or committed.
 *
 * # Thread Safety
 *
 * It is not safe to call this function concurrently with the same proof context
 * nor is it safe to call any other function that accesses the same proof context
 * concurrently. The caller must ensure exclusive access to the proof context
 * for the duration of the call.
 */
struct HashResult fwd_db_verify_and_commit_range_proof(const struct DatabaseHandle *_db,
                                                       struct VerifyRangeProofArgs _args);

/**
 * Verify a change proof and prepare a proposal to later commit or drop.
 *
 * # Arguments
 *
 * - `db` - The database to verify the proof against.
 * - `args` - The arguments for verifying the change proof.
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the caller provided a null pointer to either
 *   the database or the proof.
 * - [`VoidResult::Ok`] if the proof was successfully verified.
 * - [`VoidResult::Err`] containing an error message if the proof could not be verified
 *
 * # Thread Safety
 *
 * It is not safe to call this function concurrently with the same proof context
 * nor is it safe to call any other function that accesses the same proof context
 * concurrently. The caller must ensure exclusive access to the proof context
 * for the duration of the call.
 */
struct VoidResult fwd_db_verify_change_proof(const struct DatabaseHandle *_db,
                                             struct VerifyChangeProofArgs _args);

/**
 * Verify a range proof and prepare a proposal to later commit or drop. If the
 * proof has already been verified, the cached validation context will be used
 * to avoid re-verifying the proof.
 *
 * # Arguments
 *
 * - `db` - The database to verify the proof against.
 * - `args` - The arguments for verifying the range proof.
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the caller provided a null pointer to either
 *   the database or the proof.
 * - [`VoidResult::Ok`] if the proof was successfully verified.
 * - [`VoidResult::Err`] containing an error message if the proof could not be verified
 *
 * # Thread Safety
 *
 * It is not safe to call this function concurrently with the same proof context
 * nor is it safe to call any other function that accesses the same proof context
 * concurrently. The caller must ensure exclusive access to the proof context
 * for the duration of the call.
 */
struct VoidResult fwd_db_verify_range_proof(const struct DatabaseHandle *_db,
                                            struct VerifyRangeProofArgs _args);

/**
 * Frees the memory associated with a `ChangeProofContext`.
 *
 * # Arguments
 *
 * * `proof` - The `ChangeProofContext` to free, previously returned from any Rust function.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the memory was successfully freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 */
struct VoidResult fwd_free_change_proof(struct ChangeProofContext *proof);

/**
 * Consumes the [`OwnedBytes`] and frees the memory associated with it.
 *
 * # Arguments
 *
 * * `bytes` - The [`OwnedBytes`] struct to free, previously returned from any
 *   function from this library.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the memory was successfully freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 *
 * # Safety
 *
 * The caller must ensure that the `bytes` struct is valid and that the memory
 * it points to is uniquely owned by this object. However, if `bytes.ptr` is null,
 * this function does nothing.
 */
struct VoidResult fwd_free_owned_bytes(OwnedBytes bytes);

/**
 * Consumes the [`ProposalHandle`], cancels the proposal, and frees the memory.
 *
 * # Arguments
 *
 * * `proposal` - A pointer to a [`ProposalHandle`] previously returned from a
 *   function from this library.
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the provided proposal handle is null.
 * - [`VoidResult::Ok`] if the proposal was successfully cancelled and freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 *
 * # Safety
 *
 * The caller must ensure that the `proposal` is not null and that it points to
 * a valid [`ProposalHandle`] previously returned by a function from this library.
 *
 * The caller must ensure that the proposal was not committed. [`fwd_commit_proposal`]
 * will consume the proposal automatically.
 */
struct VoidResult fwd_free_proposal(struct ProposalHandle *proposal);

/**
 * Frees the memory associated with a `RangeProofContext`.
 *
 * # Arguments
 *
 * * `proof` - The `RangeProofContext` to free, previously returned from any Rust function.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the memory was successfully freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 */
struct VoidResult fwd_free_range_proof(struct RangeProofContext *proof);

/**
 * Gather latest metrics for this process.
 *
 * # Returns
 *
 * - [`ValueResult::None`] if the gathered metrics resulted in an empty string.
 * - [`ValueResult::Some`] the gathered metrics as an [`OwnedBytes`] (with
 *   guaranteed to be utf-8 data, not null terminated).
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error or value.
 */
struct ValueResult fwd_gather(void);

/**
 * Gets the value associated with the given key from the proposal provided.
 *
 * # Arguments
 *
 * * `handle` - The proposal handle returned by [`fwd_propose_on_db`] or
 *   [`fwd_propose_on_proposal`].
 * * `key` - The key to look up, as a [`BorrowedBytes`].
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ValueResult::None`] if the key was not found.
 * - [`ValueResult::Some`] if the key was found with the associated value.
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`ProposalHandle`]
 * * ensure that `key` is valid for [`BorrowedBytes`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated [`OwnedBytes`]
 *   returned in the result.
 */
struct ValueResult fwd_get_from_proposal(const struct ProposalHandle *handle, BorrowedBytes key);

/**
 * Gets a value assoicated with the given root hash and key.
 *
 * The hash may refer to a historical revision or an existing proposal.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `root` - The root hash to look up as a [`BorrowedBytes`]
 * * `key` - The key to look up as a [`BorrowedBytes`]
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ValueResult::RevisionNotFound`] if no revision was found for the specified root.
 * - [`ValueResult::None`] if the key was not found.
 * - [`ValueResult::Some`] if the key was found with the associated value.
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `root` is a valid for [`BorrowedBytes`]
 * * ensure that `key` is a valid for [`BorrowedBytes`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated [`OwnedBytes`]
 *   returned in the result.
 */
struct ValueResult fwd_get_from_root(const struct DatabaseHandle *db,
                                     BorrowedBytes root,
                                     BorrowedBytes key);

/**
 * Gets the value associated with the given key from the database for the
 * latest revision.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `key` - The key to look up as a [`BorrowedBytes`]
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ValueResult::RevisionNotFound`] if no revision was found for the root
 *   (i.e., there is no current root).
 * - [`ValueResult::None`] if the key was not found.
 * - [`ValueResult::Some`] if the key was found with the associated value.
 * - [`ValueResult::Err`] if an error occurred while retrieving the value.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`].
 * * ensure that `key` is valid for [`BorrowedBytes`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error or value.
 *
 * [`BorrowedBytes`]: crate::value::BorrowedBytes
 */
struct ValueResult fwd_get_latest(const struct DatabaseHandle *db, BorrowedBytes key);

/**
 * Open a database with the given arguments.
 *
 * # Arguments
 *
 * See [`DatabaseHandleArgs`].
 *
 * # Returns
 *
 * - [`HandleResult::Ok`] with the database handle if successful.
 * - [`HandleResult::Err`] if an error occurs while opening the database.
 *
 * # Safety
 *
 * The caller must:
 * - ensure that the database is freed with [`fwd_close_db`] when no longer needed.
 * - ensure that the database handle is freed only after freeing or committing
 *   all proposals created on it.
 */
struct HandleResult fwd_open_db(struct DatabaseHandleArgs args);

/**
 * Proposes a batch of operations to the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `values` - A [`BorrowedKeyValuePairs`] containing the key-value pairs to put.
 *
 * # Returns
 *
 * - [`ProposalResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ProposalResult::Ok`] if the proposal was created, with the proposal handle
 *   and calculated root hash.
 * - [`ProposalResult::Err`] if an error occurred while creating the proposal.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `values` is valid for [`BorrowedKeyValuePairs`]
 * * call [`fwd_commit_proposal`] or [`fwd_free_proposal`] to free the memory
 *   associated with the proposal. And, the caller must ensure this is done
 *   before calling [`fwd_close_db`] to avoid memory leaks or undefined behavior.
 */
struct ProposalResult fwd_propose_on_db(const struct DatabaseHandle *db,
                                        BorrowedKeyValuePairs values);

/**
 * Proposes a batch of operations to the database on top of an existing proposal.
 *
 * # Arguments
 *
 * * `handle` - The proposal handle returned by [`fwd_propose_on_db`] or
 *   [`fwd_propose_on_proposal`].
 * * `values` - A [`BorrowedKeyValuePairs`] containing the key-value pairs to put.
 *
 * # Returns
 *
 * - [`ProposalResult::NullHandlePointer`] if the provided database handle is null.
 * - [`ProposalResult::Ok`] if the proposal was created, with the proposal handle
 *   and calculated root hash.
 * - [`ProposalResult::Err`] if an error occurred while creating the proposal.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `handle` is a valid pointer to a [`ProposalHandle`]
 * * ensure that `values` is valid for [`BorrowedKeyValuePairs`]
 * * call [`fwd_commit_proposal`] or [`fwd_free_proposal`] to free the memory
 *   associated with the proposal. And, the caller must ensure this is done
 *   before calling [`fwd_close_db`] to avoid memory leaks or undefined behavior.
 */
struct ProposalResult fwd_propose_on_proposal(const struct ProposalHandle *handle,
                                              BorrowedKeyValuePairs values);

/**
 * Returns the next key range that should be fetched after processing the
 * current set of key-value pairs in a range proof that was truncated.
 *
 * Can be called multiple times to get subsequent disjoint key ranges until
 * it returns [`NextKeyRangeResult::None`], indicating there are no more keys to
 * fetch and the proof is complete.
 *
 * # Arguments
 *
 * - `proof` - A [`RangeProofContext`] previously returned from the create
 *   methods and has been prepared into a proposal or already committed.
 *
 * # Returns
 *
 * - [`NextKeyRangeResult::NullHandlePointer`] if the caller provided a null pointer.
 * - [`NextKeyRangeResult::NotPrepared`] if the proof has not been prepared into
 *   a proposal nor committed to the database.
 * - [`NextKeyRangeResult::None`] if there are no more keys to fetch.
 * - [`NextKeyRangeResult::Some`] containing the next key range to fetch.
 * - [`NextKeyRangeResult::Err`] containing an error message if the next key range
 *   could not be determined.
 *
 * # Thread Safety
 *
 * It is not safe to call this function concurrently with the same proof context
 * nor is it safe to call any other function that accesses the same proof context
 * concurrently. The caller must ensure exclusive access to the proof context
 * for the duration of the call.
 */
struct NextKeyRangeResult fwd_range_proof_find_next_key(struct RangeProofContext *_proof);

/**
 * Deserialize a `RangeProof` from bytes.
 *
 * # Arguments
 *
 * - `bytes` - The bytes to deserialize the proof from.
 *
 * # Returns
 *
 * - [`RangeProofResult::NullHandlePointer`] if the caller provided a null or zero-length slice.
 * - [`RangeProofResult::Ok`] containing a pointer to the `RangeProofContext` if the proof
 *   was successfully parsed. This does not imply that the proof is valid, only that it is
 *   well-formed. The verify method must be called to ensure the proof is cryptographically valid.
 * - [`RangeProofResult::Err`] containing an error message if the proof could not be parsed.
 */
struct RangeProofResult fwd_range_proof_from_bytes(BorrowedBytes bytes);

/**
 * Serialize a `RangeProof` to bytes.
 *
 * # Arguments
 *
 * - `proof` - A [`RangeProofContext`] previously returned from the create
 *   method. If from a parsed proof, the proof will not be verified before
 *   serialization.
 *
 * # Returns
 *
 * - [`ValueResult::NullHandlePointer`] if the caller provided a null pointer.
 * - [`ValueResult::Some`] containing the serialized bytes if successful.
 * - [`ValueResult::Err`] if the caller provided a null pointer.
 */
struct ValueResult fwd_range_proof_to_bytes(const struct RangeProofContext *proof);

/**
 * Verify a range proof against the given start and end keys and root hash. The
 * proof will be updated with the validation context if the proof is valid to
 * avoid re-verifying it during commit.
 *
 * # Arguments
 *
 * - `args` - The arguments for verifying the range proof.
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the caller provided a null pointer to the proof.
 * - [`VoidResult::Ok`] if the proof was successfully verified.
 * - [`VoidResult::Err`] containing an error message if the proof could not be verified.
 *
 * # Thread Safety
 *
 * It is not safe to call this function concurrently with the same proof context
 * nor is it safe to call any other function that accesses the same proof context
 * concurrently. The caller must ensure exclusive access to the proof context
 * for the duration of the call.
 */
struct VoidResult fwd_range_proof_verify(struct VerifyRangeProofArgs _args);

/**
 * Get the root hash of the latest version of the database
 *
 * # Argument
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the database is empty.
 * - [`HashResult::Some`] with the root hash of the database.
 * - [`HashResult::Err`] if an error occurred while looking up the root hash.
 *
 * # Safety
 *
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned
 *   by value).
 */
struct HashResult fwd_root_hash(const struct DatabaseHandle *db);

/**
 * Start logs for this process.
 *
 * # Arguments
 *
 * See [`LogArgs`].
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error (if any).
 */
struct VoidResult fwd_start_logs(struct LogArgs args);

/**
 * Start metrics recorder for this process.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 */
struct VoidResult fwd_start_metrics(void);

/**
 * Start metrics recorder and exporter for this process.
 *
 * # Arguments
 *
 * * `metrics_port` - the port where metrics will be exposed at
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error (if any).
 */
struct VoidResult fwd_start_metrics_with_exporter(uint16_t metrics_port);
