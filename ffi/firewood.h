// Copyright (C) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE.md for licensing terms.

// This file was @generated by cbindgen. Do not edit this file manually.
// Run `cargo build --target firewood-ffi` to regenerate this file.

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>


/**
 * The cache read strategy to use for the database.
 *
 * This controls what types of database operations are cached to improve
 * performance by avoiding redundant disk reads and computations.
 */
enum CacheReadStrategy {
  /**
   * Only cache write operations. This is the most conservative strategy
   * that minimizes memory usage but may result in more disk reads.
   */
  CacheReadStrategy_WritesOnly = 0,
  /**
   * Cache both write operations and branch node reads. This provides
   * better performance for tree traversal operations while keeping
   * memory usage moderate.
   */
  CacheReadStrategy_BranchReads = 1,
  /**
   * Cache all read and write operations. This provides the best performance
   * but uses the most memory as it caches leaf nodes and values in addition
   * to branch nodes.
   */
  CacheReadStrategy_All = 2,
};
typedef uint8_t CacheReadStrategy;

/**
 * A handle to the database, returned by `fwd_open_db`.
 *
 * These handles are passed to the other FFI functions.
 *
 */
typedef struct DatabaseHandle DatabaseHandle;

/**
 * A root database hash key, used in FFI functions that provide or return
 * a root hash. This type requires no allocation and can be copied freely
 * and droppped without any additional overhead.
 *
 * This is useful because it is the same size as 4 words which is equivalent
 * to 2 heap-allocated slices (pointer + length each), or 1.5 vectors (which
 * uses an extra word for allocation capacity) and it can be passed around
 * without needing to allocate or deallocate memory.
 */
typedef struct HashKey {
  uint8_t _0[32];
} HashKey;

/**
 * A Rust-owned vector of bytes that can be passed to C code.
 *
 * C callers must free this memory using the respective FFI function for the
 * concrete type (but not using the `free` function from the C standard library).
 */
typedef struct OwnedSlice_u8 {
  uint8_t *ptr;
  size_t len;
} OwnedSlice_u8;

/**
 * A type alias for a rust-owned byte slice.
 */
typedef struct OwnedSlice_u8 OwnedBytes;

/**
 * A result type returned from FFI functions return the database root hash. This
 * may or may not be after a mutation.
 */
typedef enum HashResult_Tag {
  /**
   * The caller provided a null pointer to a database handle.
   */
  HashResult_NullHandlePointer,
  /**
   * The proposal resulted in an empty database or the database currently has
   * no root hash.
   */
  HashResult_None,
  /**
   * The mutation was successful and the root hash is returned, if this result
   * was from a mutation. Otherwise, this is the current root hash of the
   * database.
   */
  HashResult_Some,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  HashResult_Err,
} HashResult_Tag;

typedef struct HashResult {
  HashResult_Tag tag;
  union {
    struct {
      struct HashKey some;
    };
    struct {
      OwnedBytes err;
    };
  };
} HashResult;

/**
 * A borrowed byte slice. Used to represent data that was passed in from C
 * callers and will not be freed or retained by Rust code.
 */
typedef struct BorrowedSlice_u8 {
  /**
   * A pointer to the slice of bytes. This can be null if the slice is empty.
   *
   * If the pointer is not null, it must point to a valid slice of `len`
   * elements sized and aligned for `T`.
   *
   * As a note, [`NonNull`] is not appropriate here because [`NonNull`] pointer
   * provenance requires mutable access to the pointer, which is not an invariant
   * we want to enforce here. We want (and require) the pointer to be immutable.
   *
   * [`NonNull`]: std::ptr::NonNull
   */
  const uint8_t *ptr;
  /**
   * The length of the slice. It is ignored if the pointer is null; however,
   * if the pointer is not null, it must be equal to the number of elements
   * pointed to by `ptr`.
   */
  size_t len;
} BorrowedSlice_u8;

/**
 * A type alias for a borrowed byte slice.
 *
 * C callers can use this to pass in a byte slice that will not be freed by Rust
 * code.
 *
 * C callers must ensure that the pointer, if not null, points to a valid slice
 * of bytes of length `len`. C callers must also ensure that the slice is valid
 * for the duration of the C function call that was passed this slice.
 */
typedef struct BorrowedSlice_u8 BorrowedBytes;

/**
 * A `KeyValue` represents a key-value pair, passed to the FFI.
 */
typedef struct KeyValuePair {
  BorrowedBytes key;
  BorrowedBytes value;
} KeyValuePair;

/**
 * A borrowed byte slice. Used to represent data that was passed in from C
 * callers and will not be freed or retained by Rust code.
 */
typedef struct BorrowedSlice_KeyValuePair {
  /**
   * A pointer to the slice of bytes. This can be null if the slice is empty.
   *
   * If the pointer is not null, it must point to a valid slice of `len`
   * elements sized and aligned for `T`.
   *
   * As a note, [`NonNull`] is not appropriate here because [`NonNull`] pointer
   * provenance requires mutable access to the pointer, which is not an invariant
   * we want to enforce here. We want (and require) the pointer to be immutable.
   *
   * [`NonNull`]: std::ptr::NonNull
   */
  const struct KeyValuePair *ptr;
  /**
   * The length of the slice. It is ignored if the pointer is null; however,
   * if the pointer is not null, it must be equal to the number of elements
   * pointed to by `ptr`.
   */
  size_t len;
} BorrowedSlice_KeyValuePair;

/**
 * A type alias for a borrowed slice of [`KeyValuePair`]s.
 *
 * C callers can use this to pass in a slice of key-value pairs that will not
 * be freed by Rust code.
 *
 * C callers must ensure that the pointer, if not null, points to a valid slice
 * of key-value pairs of length `len`. C callers must also ensure that the slice
 * is valid for the duration of the C function call that was passed this slice.
 */
typedef struct BorrowedSlice_KeyValuePair BorrowedKeyValuePairs;

/**
 * The result type returned from an FFI function that returns no value but may
 * return an error.
 */
typedef enum VoidResult_Tag {
  /**
   * The caller provided a null pointer to the input handle.
   */
  VoidResult_NullHandlePointer,
  /**
   * The operation was successful and no error occurred.
   */
  VoidResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. Its
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  VoidResult_Err,
} VoidResult_Tag;

typedef struct VoidResult {
  VoidResult_Tag tag;
  union {
    struct {
      OwnedBytes err;
    };
  };
} VoidResult;

/**
 * A value returned by the FFI.
 *
 * This is used in several different ways, including:
 * * An C-style string.
 * * An ID for a proposal.
 * * A byte slice containing data.
 *
 * For more details on how the data may be stored, refer to the function signature
 * that returned it or the `From` implementations.
 *
 * The data stored in this struct (if `data` is not null) must be manually freed
 * by the caller using `fwd_free_value`.
 *
 */
typedef struct Value {
  size_t len;
  uint8_t *data;
} Value;

typedef uint32_t ProposalId;

/**
 * The result type returned from the open or create database functions.
 */
typedef enum HandleResult_Tag {
  /**
   * The database was opened or created successfully and the handle is
   * returned as an opaque pointer.
   *
   * The caller must ensure that [`fwd_close_db`] is called to free resources
   * associated with this handle when it is no longer needed.
   *
   * [`fwd_close_db`]: crate::fwd_close_db
   */
  HandleResult_Ok,
  /**
   * An error occurred and the message is returned as an [`OwnedBytes`]. If
   * value is guaranteed to contain only valid UTF-8.
   *
   * The caller must call [`fwd_free_owned_bytes`] to free the memory
   * associated with this error.
   *
   * [`fwd_free_owned_bytes`]: crate::fwd_free_owned_bytes
   */
  HandleResult_Err,
} HandleResult_Tag;

typedef struct HandleResult {
  HandleResult_Tag tag;
  union {
    struct {
      struct DatabaseHandle *ok;
    };
    struct {
      OwnedBytes err;
    };
  };
} HandleResult;

/**
 * Arguments for creating or opening a database. These are passed to [`fwd_open_db`]
 *
 * [`fwd_open_db`]: crate::fwd_open_db
 */
typedef struct DatabaseHandleArgs {
  /**
   * The path to the database file.
   *
   * This must be a valid UTF-8 string, even on Windows.
   *
   * If this is empty, an error will be returned.
   */
  BorrowedBytes path;
  /**
   * The size of the node cache. If zero, the default size of 1,500,000 nodes
   * will be used.
   */
  size_t cache_size;
  /**
   * The size of the free list cache. If zero, the default size of 40,000 nodes
   * will be used.
   */
  size_t free_list_cache_size;
  /**
   * The maximum number of revisions to keep. If zero, the default of 128
   * revisions will be used.
   *
   * If this is less than 2, an error will be returned.
   */
  size_t revisions;
  /**
   * The cache read strategy to use.
   */
  CacheReadStrategy strategy;
  /**
   * Whether to truncate the database file if it exists.
   */
  bool truncate;
} DatabaseHandleArgs;

/**
 * Arguments for initializing logging for the Firewood FFI.
 */
typedef struct LogArgs {
  /**
   * The file path where logs for this process are stored.
   *
   * If empty, this is set to `${TMPDIR}/firewood-log.txt`.
   *
   * This is required to be a valid UTF-8 string.
   */
  BorrowedBytes path;
  /**
   * The filter level for logs.
   *
   * If empty, this is set to `info`.
   *
   * This is required to be a valid UTF-8 string.
   */
  BorrowedBytes filter_level;
} LogArgs;

/**
 * Puts the given key-value pairs into the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 * * `values` - A [`BorrowedKeyValuePairs`] containing the key-value pairs to put.
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the commit resulted in an empty database.
 * - [`HashResult::Some`] if the commit was successful, containing the new root hash.
 * - [`HashResult::Err`] if an error occurred while committing the batch.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * ensure that `values` is valid for [`BorrowedKeyValuePairs`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned by
 *   value).
 */
struct HashResult fwd_batch(const struct DatabaseHandle *db, BorrowedKeyValuePairs values);

/**
 * Close and free the memory for a database handle
 *
 * # Arguments
 *
 * * `db` - The database handle to close, previously returned from a call to [`fwd_open_db`].
 *
 * # Returns
 *
 * - [`VoidResult::NullHandlePointer`] if the provided database handle is null.
 * - [`VoidResult::Ok`] if the database handle was successfully closed and freed.
 * - [`VoidResult::Err`] if the process panics while closing the database handle.
 *
 * # Safety
 *
 * Callers must ensure that:
 *
 * - `db` is a valid pointer to a [`DatabaseHandle`] returned by [`fwd_open_db`].
 * - The database handle is not used after this function is called.
 */
struct VoidResult fwd_close_db(struct DatabaseHandle *db);

/**
 * Commits a proposal to the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by `open_db`
 * * `proposal_id` - The ID of the proposal to commit
 *
 * # Returns
 *
 * A `Value` containing {0, null} if the commit was successful.
 * A `Value` containing {0, "error message"} if the commit failed.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 * The caller must ensure that `db` is a valid pointer returned by `open_db`
 *
 */
struct HashResult fwd_commit(const struct DatabaseHandle *db, uint32_t proposal_id);

/**
 * Drops a proposal from the database.
 * The propopsal's data is now inaccessible, and can be freed by the `RevisionManager`.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by `open_db`
 * * `proposal_id` - The ID of the proposal to drop
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 * The caller must ensure that `db` is a valid pointer returned by `open_db`
 *
 */
struct Value fwd_drop_proposal(const struct DatabaseHandle *db, uint32_t proposal_id);

/**
 * Consumes the [`OwnedBytes`] and frees the memory associated with it.
 *
 * # Arguments
 *
 * * `bytes` - The [`OwnedBytes`] struct to free, previously returned from any
 *   function from this library.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the memory was successfully freed.
 * - [`VoidResult::Err`] if the process panics while freeing the memory.
 *
 * # Safety
 *
 * The caller must ensure that the `bytes` struct is valid and that the memory
 * it points to is uniquely owned by this object. However, if `bytes.ptr` is null,
 * this function does nothing.
 */
struct VoidResult fwd_free_owned_bytes(OwnedBytes bytes);

/**
 * Frees the memory associated with a `Value`.
 *
 * # Arguments
 *
 * * `value` - The `Value` to free, previously returned from any Rust function.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 * The caller must ensure that `value` is a valid pointer.
 *
 * # Panics
 *
 * This function panics if `value` is `null`.
 *
 */
struct VoidResult fwd_free_value(struct Value *value);

/**
 * Gather latest metrics for this process.
 *
 * # Returns
 *
 * A `Value` containing {len, bytes} representing the latest metrics for this process.
 * A `Value` containing {0, "error message"} if unable to get the latest metrics.
 */
struct Value fwd_gather(void);

/**
 * Gets the value associated with the given key from the proposal provided.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by `open_db`
 * * `id` - The ID of the proposal to get the value from
 * * `key` - The key to look up, in `BorrowedBytes` form
 *
 * # Returns
 *
 * A `Value` containing the requested value.
 * A `Value` containing {0, "error message"} if the get failed.
 *
 * # Safety
 *
 * The caller must:
 *  * ensure that `db` is a valid pointer returned by `open_db`
 *  * ensure that `key` is a valid pointer to a `Value` struct
 *  * call `free_value` to free the memory associated with the returned `Value`
 *
 */
struct Value fwd_get_from_proposal(const struct DatabaseHandle *db,
                                   ProposalId id,
                                   BorrowedBytes key);

/**
 * Gets a value assoicated with the given root hash and key.
 *
 * The hash may refer to a historical revision or an existing proposal.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by `open_db`
 * * `root` - The root hash to look up, in `BorrowedBytes` form
 * * `key` - The key to look up, in `BorrowedBytes` form
 *
 * # Returns
 *
 * A `Value` containing the requested value.
 * A `Value` containing {0, "error message"} if the get failed.
 *
 * # Safety
 *
 * The caller must:
 * * ensure that `db` is a valid pointer returned by `open_db`
 * * ensure that `key` is a valid pointer to a `Value` struct
 * * ensure that `root` is a valid pointer to a `Value` struct
 * * call `free_value` to free the memory associated with the returned `Value`
 *
 */
struct Value fwd_get_from_root(const struct DatabaseHandle *db,
                               BorrowedBytes root,
                               BorrowedBytes key);

/**
 * Gets the value associated with the given key from the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by `open_db`
 * * `key` - The key to look up, in `BorrowedBytes` form
 *
 * # Returns
 *
 * A `Value` containing the requested value.
 * A `Value` containing {0, "error message"} if the get failed.
 * There is one error case that may be expected to be null by the caller,
 * but should be handled externally: The database has no entries - "IO error: Root hash not found"
 * This is expected behavior if the database is empty.
 *
 * # Safety
 *
 * The caller must:
 *  * ensure that `db` is a valid pointer returned by `open_db`
 *  * ensure that `key` is a valid pointer to a `Value` struct
 *  * call `free_value` to free the memory associated with the returned `Value`
 *
 */
struct Value fwd_get_latest(const struct DatabaseHandle *db, BorrowedBytes key);

/**
 * Open a database with the given arguments.
 *
 * # Arguments
 *
 * See [`DatabaseHandleArgs`].
 *
 * # Returns
 *
 * - [`HandleResult::Ok`] with the database handle if successful.
 * - [`HandleResult::Err`] if an error occurs while opening the database.
 *
 * # Safety
 *
 * The caller must:
 * - ensure that the database is freed with [`fwd_close_db`] when no longer needed.
 * - ensure that the database handle is freed only after freeing or committing
 *   all proposals created on it.
 */
struct HandleResult fwd_open_db(struct DatabaseHandleArgs args);

/**
 * Proposes a batch of operations to the database.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by `open_db`
 * * `values` - A `BorrowedKeyValuePairs` struct containing the key-value pairs to put.
 *
 * # Returns
 *
 * On success, a `Value` containing {len=id, data=hash}. In this case, the
 * hash will always be 32 bytes, and the id will be non-zero.
 * On failure, a `Value` containing {0, "error message"}.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 * The caller must:
 *  * ensure that `db` is a valid pointer returned by `open_db`
 *  * ensure that `values` is a valid pointer and that it points to an array of `KeyValue` structs of length `nkeys`.
 *  * ensure that the `Value` fields of the `KeyValue` structs are valid pointers.
 *
 */
struct Value fwd_propose_on_db(const struct DatabaseHandle *db,
                               BorrowedKeyValuePairs values);

/**
 * Proposes a batch of operations to the database on top of an existing proposal.
 *
 * # Arguments
 *
 * * `db` - The database handle returned by `open_db`
 * * `proposal_id` - The ID of the proposal to propose on
 * * `values` - A `BorrowedKeyValuePairs` struct containing the key-value pairs to put.
 *
 * # Returns
 *
 * On success, a `Value` containing {len=id, data=hash}. In this case, the
 * hash will always be 32 bytes, and the id will be non-zero.
 * On failure, a `Value` containing {0, "error message"}.
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 * The caller must:
 *  * ensure that `db` is a valid pointer returned by `open_db`
 *  * ensure that `values` is a valid pointer and that it points to an array of `KeyValue` structs of length `nkeys`.
 *  * ensure that the `Value` fields of the `KeyValue` structs are valid pointers.
 *
 */
struct Value fwd_propose_on_proposal(const struct DatabaseHandle *db,
                                     ProposalId proposal_id,
                                     BorrowedKeyValuePairs values);

/**
 * Get the root hash of the latest version of the database
 *
 * # Argument
 *
 * * `db` - The database handle returned by [`fwd_open_db`]
 *
 * # Returns
 *
 * - [`HashResult::NullHandlePointer`] if the provided database handle is null.
 * - [`HashResult::None`] if the database is empty.
 * - [`HashResult::Some`] with the root hash of the database.
 * - [`HashResult::Err`] if an error occurred while looking up the root hash.
 *
 * # Safety
 *
 * * ensure that `db` is a valid pointer to a [`DatabaseHandle`]
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error ([`HashKey`] does not need to be freed as it is returned
 *   by value).
 */
struct HashResult fwd_root_hash(const struct DatabaseHandle *db);

/**
 * Start logs for this process.
 *
 * # Arguments
 *
 * See [`LogArgs`].
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error (if any).
 */
struct VoidResult fwd_start_logs(struct LogArgs args);

/**
 * Start metrics recorder for this process.
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 */
struct VoidResult fwd_start_metrics(void);

/**
 * Start metrics recorder and exporter for this process.
 *
 * # Arguments
 *
 * * `metrics_port` - the port where metrics will be exposed at
 *
 * # Returns
 *
 * - [`VoidResult::Ok`] if the recorder was initialized.
 * - [`VoidResult::Err`] if an error occurs during initialization.
 *
 * # Safety
 *
 * The caller must:
 * * call [`fwd_free_owned_bytes`] to free the memory associated with the
 *   returned error (if any).
 */
struct VoidResult fwd_start_metrics_with_exporter(uint16_t metrics_port);
