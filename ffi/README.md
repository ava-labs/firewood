# A firewood golang interface

This allows calling into firewood from golang

## Building

First, build the release version (`cargo build --release`). This creates the ffi
interface file "firewood.h" as a side effect.

Then, you can run the tests in go, using `go test .`

## Development
Iterative building is unintuitive for the ffi and some common sources of confusion are listed below.

### FFI Naming
Because the C header file is autogenerated from the Rust code, the naming matches exactly (due to the `no_mangle` macro). However, the C definitions imported in Go do not match exactly, and are prefixed with `struct_`. Function naming is the same as the header file.

### CGO Regeneration
As you edit any Rust code and save the file in VS Code, the `firewood.h` file is automatically updated with edited function and struct definitions. However, the Go linter will not recognize these until you manually update it by going to the top of a file, right above the `import "C"` definition, and click on the small letters saying "regenerate CGO definitions". This will allow the linter to use the altered definitions. In general, you should use `go tool cgo firewood.go` to generate the header file and use it in the file.

### Testing
Although the VS Code testing feature does work, there are some quirks in ensuring proper building. The Rust code must be compiled separated, and sometimes the `go test` command continues to use a cached result. Whenever testing after making changes to the Rust/C builds, the cache should be cleared if results don't seem correct. Do not compile with `--features ethhash`, as some tests will fail.

To ensure there are no memory leaks, the easiest way is to use your preferred CLI tool (e.g. `valgrind` for Linux, `leaks` for macOS) and compile the tests into a binary. You must not compile a release binary to ensure all memory can be managed. An example flow is given below.
```
cd ffi
cargo build # use debug
go test -a -c -o binary_file # ignore cache
leaks --nostacks --atExit -- ./binary_file
```