# Releasing firewood

Releasing firewood is straightforward and can mostly be done in CI. Updating the
Cargo.toml file is currently manual.

Firewood is made up of several sub-projects in a workspace. Each project is in
its own crate and has an independent version.

## Workspace Dependencies

Ensure the following tools are installed before beginning:

```shell
cargo install --locked just git-cliff cargo-edit
```

## Git Branch

Before making changes, create a new branch (if not already on one):

```console
$ git fetch
$ git switch -c release/v0.1.1 origin/main
branch 'release/v0.1.1' set up to track 'origin/main'.
Switched to a new branch 'release/v0.1.1'
```

If already on a new branch, ensure `HEAD` is the same as the remote's `main`.
As the upstream repo changes, rebase the branch onto `main` so that the changes
from `git cliff` follow the repository history in the correct linear order.

On rebase, quickly redo the generative steps with `just`:

```shell
just release-step-update-rust-dependencies && just release-step-refresh-changelog v0.1.1
```

## Dependency upgrades

### Rust MSRV

Optionally, the minimum supported rust version can be bumped. See
<https://blog.rust-lang.org/releases/latest> for the latest version. Best
effort 2 releases behind the current latest stable [^1]. However, Rust evolves
fairly quickly and we occasionally want to take advantage of a new improvement
before the stable release matures.

Updating the Rust MSRV requires edits in two places:

- [clippy.toml]
  - Update the root `msrv` setting to indicate the set MSRV. This configures
    clippy to include newer lints that would otherwise be incorrect with a lower
    MSRV; such as recommending newly stablized features that were unstable in
    the older release.
- [Cargo.toml]
  - Update `workspace.package.rust-version` which will propagate through the
    other cargo packages that have `package.rust-version.workspace = true` set.

[^1]: e.g., with 1.91 stable, 1.89 is the best effort MSRV

### Cargo Dependencies

```shell
just release-step-update-rust-dependencies
```

See the note in [justfile] about how the `cargo upgrade --incompatible` may fail
if dependency upgrades require code changes. If significant changes are needed
to resolve the dependency issues, do that in a separate step from release.

### Go Dependencies

Go dependencies are updated on an as-needed basis, usually for security.

## Package Version

Next, update the workspace versions as needed. Only the packages with changes should have their version bumped. Transitive changes do not require a version bump unless the transitive dependency requires a semver upgrade.

For semver breaking changes, all downstream packages require upgrading to the new version as well.

## Dependency Version

`cargo publish` for each package requires that each dependency specify _a_ version;
therefore, the next step is to bump the dependency declarations to the new version.
Packages within the workspace that are used as libraries are also defined within
the [`[workspace.dependencies]`](https://doc.rust-lang.org/cargo/reference/workspaces.html#the-dependencies-table)
table. E.g.,:

```toml
[workspace.dependencies]
# workspace local packages
firewood = { path = "firewood", version = "0.1.1" }
```

This allows packages within the workspace to inherit the dependency,
including path, version, and workspace-level features by adding `workspace = true`
to the dependency table (note: using `cargo add -p firewood-fwdctl firewood-metrics`
would automatically add the dependency with `workspace = true`).

```toml
[dependencies]
firewood-macros.workspace = true

# more complex example
[target.'cfg(target_os = "linux")'.dependencies]
firewood-storage = { workspace = true, features = ["io-uring"] }

[target.'cfg(not(target_os = "linux"))'.dependencies]
firewood-storage.workspace = true
```

Thefefore, after updating the `workspace.package.version` value, we must update
the dependency versions to match.

Run `cargo update` after editing the `Cargo.toml` files to ensure the lockfile
is correct and reflects the new package versions.

## Changelog

To build the changelog, see git-cliff.org. Short version:

```sh
just release-step-refresh-changelog v0.1.1
```

where `v0.1.1` is the newest tag. This is a required paramter to ensure the
changelog has the correct headers.

## Commit

Commit the version bump and change log updates. Using the summary prefix:

> chore(release): prepare for

will cause `git-cliff` to omit the commit from the changelog. This is why
substantive changes when upgrading dependencies should be in their own commit.
If you do not use the prefix, there will be an egg-and-chicken problem as the
commit message generated by GitHub includes the pull request as a suffix.
Manually resolve this in the CHANGELOG if needed; otherwise, the CHANGELOG will
have irrelevant changes on future releases.

## Review

> â— Be sure to update the versions of all sub-projects before creating a new
> release. Open a PR with the updated versions and merge it before continuing to
> the next step.

## Publish

To trigger a release, push a tag to the main branch matching the new version,

```sh
# be sure to switch back to the main branch before tagging
git checkout main
git pull --prune
git tag -s -a v0.1.1 -m 'Release v0.1.1'
git push origin v0.1.1
```

for `v0.1.1` for the merged version change. The CI will automatically publish a
draft release which consists of release notes and changes (see
[.github/workflows/release.yaml](.github/workflows/release.yaml)).

## Milestone

> NOTE: this should be automated as well.

Close the GitHub milestone for the version that was released. Be sure to create
a new milestone for the next version if one does not already exist. Carry over
any incomplete tasks to the next milestone.
